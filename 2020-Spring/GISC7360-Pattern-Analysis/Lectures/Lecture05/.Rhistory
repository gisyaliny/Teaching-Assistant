seTot <- sqrt(predSe^2+predSimKrig$simKrig.var)    # Total cell prediction standard error
library(classInt)
predSe.3 <- predTrend3$se.fit
n.col <- 6
pal <- brewer.pal(n.col,"Oranges")
seClass <- classIntervals(predSe.3, n.col, style="equal")
seCol <- findColours(seClass,pal)
plot(gridDEM,axes=T,col=seCol,pch=15,cex=2,
main="Prediction Standard Error: 3rd Order Trendsurface")
plot(river,col="blue",add=T)
legend("topleft", title = "Std.Erros",
legend = leglabs(round(seClass$brks, digits = 0)), fill = pal, bty = "o", ncol = 1)
fitTot <- predFit+predRes                          # Total predicted cell value
seTot <- sqrt(predSe.3^2+predSimKrig$simKrig.var)    # Total cell prediction standard error
## Map overall prediciton surface
fitHist<- hist(fitTot,freq=F)
lines(density(gridDEM$ELEVATION),col="red",lwd=2)
breakptsFit <- fitHist$breaks
nclFit <- length(breakptsFit)-1
palFit <- terrain.colors(nclFit)
colsFit <- palFit[findInterval(fitTot,
breakptsFit,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsFit, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="red",add=T)
legend("topright", title="Predicted DEM",legend=leglabs(round(breakptsFit,2)),
fill=palFit,bg="white",ncol=1)
title("Prediction Surface: Trend (3rd) plus Kriging Residuals")
## Map overall prediciton standard error
seHist<- hist(seTot)
breakptsSe <- seHist$breaks
nclSe <- length(breakptsSe)-1
palSe <- rev(heat.colors(nclSe))
colsSe <- palSe[findInterval(seTot,
breakptsSe,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsSe, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="red",add=T)
legend("topright", title="Prediction STD. Error",legend=leglabs(round(breakptsSe,2)),
fill=palSe,bg="white",ncol=1)
title("Prediction Standard Errors of 3rd Order DEM Surface plus Kriging Residuals")
predError <- gridDEM$ELEVATION - fitTot
(RMSETotal <- sqrt(sum(predError^2)/length(predError)))
n.col <- 5
pal <- rev(brewer.pal(n.col,"RdBu"))
seClass <- classIntervals(predError, n.col, style="equal")
seCol <- findColours(seClass,pal)
plot(predError,axes=T,col=seCol,pch=15,cex=2,
main="3rd Order Trend residual surface")
plot(river,col="blue",add=T)
legend("topleft", title = "Residual",
legend = leglabs(round(seClass$brks, digits = 0)), fill = pal, bty = "o", ncol = 1)
n.col <- 5
pal <- rev(brewer.pal(n.col,"RdBu"))
seClass <- classIntervals(predError, n.col, style="equal")
seCol <- findColours(seClass,pal)
plot(gridDEM,axes=T,col=seCol,pch=15,cex=2,
main="3rd Order Trend residual surface")
plot(river,col="blue",add=T)
legend("topleft", title = "Residual",
legend = leglabs(round(seClass$brks, digits = 0)), fill = pal, bty = "o", ncol = 1)
rm(list=ls(all=TRUE))
library(maptools); library(RColorBrewer)
setwd("G:\\UTD_Classes\\2020Spring\\GISC7360_Pattern_Analysis\\Lecture05\\KansasDEM")
# read the DEM shapefile
gridDEM <- rgdal::readOGR(dsn=getwd(), layer="DEMPointsDisRiv", integer64="warn.loss")
proj4string(gridDEM)
boxDEM <- bbox(gridDEM)
cat("Latitude range: ",boxDEM[1,2] - boxDEM[1,1],"\n")
cat("Longitude range: ",boxDEM[2,2] - boxDEM[2,1],"\n")
river <- rgdal::readOGR(dsn=getwd(), layer="RiversRevised", integer64="warn.loss")
proj4string(river)
grid.data <- as.data.frame(gridDEM)
summary(grid.data)
breakpts <- seq(250,1000,by=25)                                                 # Define Elevation classes
hist(grid.data$ELEVATION, breaks=breakpts,
xlab="Elevation (meters)", main="Distribution of DEM Elevations")          # Check Distribution
# lines(density(grid.data$ELEVATION), lwd = 2, col = "chocolate3")                # density plot
ncl <- length(breakpts)-1                                                       # Number of classes
pal <- terrain.colors(ncl)                                                      # get colors
cols <- pal[findInterval(grid.data$ELEVATION,breakpts,rightmost.closed=T)]      # assign appropriate color to each residual
library(raster)
# Place 72 Sample Points evenly in the map
range <- floor(boxDEM[,2]) - ceiling(boxDEM[,1])
coords.x1 <- seq(ceiling(boxDEM[1,1]), floor(boxDEM[1,2]),length.out = 12)
coords.x2 <- seq(ceiling(boxDEM[2,1]), floor(boxDEM[2,2]),length.out = 6)
samplePoints <- as.data.frame(expand.grid(coords.x1,coords.x2))
samplePoints <- SpatialPoints(samplePoints)
samplePoints@proj4string <- gridDEM@proj4string
library(rgeos)
elevation <- c()
riveDist <- c()
for (i in 1:72){
index <- which.min(gDistance(samplePoints[i,],gridDEM, byid=TRUE))
elevation <- c(elevation,grid.data$ELEVATION[index])
riveDist <- c(riveDist,grid.data$RIVERDIST[index])
}
samplePoints$ELEVATION <- elevation
samplePoints$RIVERDIST <- riveDist
summary(samplePoints$RIVERDIST)
summary(gridDEM$RIVERDIST)
library(maptools)
# Keep the Same Range
index <- c()
# Add Max and Min value
index <- c(index,which.min(gridDEM$RIVERDIST))
index <- c(index,which.max(gridDEM$RIVERDIST))
# Correct the quartile distribution
set.seed(1250)
# 8 from min to 1st quantile
index <- c(index,sample(which(gridDEM$RIVERDIST < quantile(gridDEM$RIVERDIST,0.25)),8))
# 5 from 1st quantile to mean
index <- c(index,sample(which(gridDEM$RIVERDIST < mean(gridDEM$RIVERDIST) & gridDEM$RIVERDIST > quantile(gridDEM$RIVERDIST,0.25)),5))
# 2 from mean to 3rd quantile
index <- c(index,sample(which(gridDEM$RIVERDIST > mean(gridDEM$RIVERDIST) & gridDEM$RIVERDIST < quantile(gridDEM$RIVERDIST,0.75)),2))
# 3 nearest to the mean
diff_mean <- sort(abs(gridDEM$RIVERDIST-mean(gridDEM$RIVERDIST)),decreasing = F)
index <- c(index,which(abs(gridDEM$RIVERDIST-mean(gridDEM$RIVERDIST)) == diff_mean[1]))
index <- c(index,which(abs(gridDEM$RIVERDIST-mean(gridDEM$RIVERDIST)) == diff_mean[2]))
index <- c(index,which(abs(gridDEM$RIVERDIST-mean(gridDEM$RIVERDIST)) == diff_mean[3]))
sample_river <-  SpatialPoints(data.frame(gridDEM@coords[index,1],gridDEM@coords[index,2]))
sample_river@proj4string <- gridDEM@proj4string
sample_river$ELEVATION <- gridDEM$ELEVATION[index]
sample_river$RIVERDIST <- gridDEM$RIVERDIST[index]
samplePoints <- spRbind(samplePoints,sample_river)
summary(samplePoints$ELEVATION)
summary(gridDEM$ELEVATION)
riveDist <- Hmisc::histbackback(samplePoints$ELEVATION, gridDEM$ELEVATION,
prob=TRUE, xlab=c("sample","map"),
main="River Distance")
## Keep the same range of elevation
index <- c()
set.seed(1250)
# Add Max and Min value (2)
index <- c(index,which.min(gridDEM$ELEVATION))
index <- c(index,which.max(gridDEM$ELEVATION))
# 1 from the 1st quantile
index <- c(index,sample(which(gridDEM$ELEVATION < quantile(gridDEM$ELEVATION,0.25)),1))
# 1 from the 3st quantile
index <- c(index,sample(which(gridDEM$ELEVATION > mean(gridDEM$ELEVATION) & gridDEM$ELEVATION < quantile(gridDEM$ELEVATION,0.75)),1))
# 4 nearest to the mean
diff_mean <- sort(abs(gridDEM$ELEVATION-mean(gridDEM$ELEVATION)),decreasing = F)
index <- c(index,sample(which(abs(gridDEM$ELEVATION-mean(gridDEM$ELEVATION)) == diff_mean[1]),4))
sample_dem <-  SpatialPoints(data.frame(gridDEM@coords[index,1],gridDEM@coords[index,2]))
sample_dem@proj4string <- gridDEM@proj4string
sample_dem$ELEVATION <- gridDEM$ELEVATION[index]
sample_dem$RIVERDIST <- gridDEM$RIVERDIST[index]
samplePoints <- spRbind(samplePoints,sample_dem)
t.test(samplePoints$ELEVATION, gridDEM$ELEVATION)
plot(gridDEM, axes=T, col=cols, pch=15,cex=1)                                   # Observed DEM Grid
plot(river,col="blue",add=T)
points(samplePoints,col= "Red",pch = 18)
title("Sample DEM Locations")
zTransCoord <- function(x,xmean,xsd,reverse=F){
if (reverse == F) x <- (x-xmean)/xsd
else x <- x*xsd+xmean
return(x)
} #end:zTransCoord
yMean <- mean(samplePoints@coords[,2]); xMean <- mean(samplePoints@coords[,1])
ySd <- sd(samplePoints@coords[,2]); xSd <- sd(samplePoints@coords[,1])
samplePoints$X <- zTransCoord(samplePoints@coords[,1],xMean,xSd)
samplePoints$Y <- zTransCoord(samplePoints@coords[,2],yMean,ySd)
gridDEM$X <- zTransCoord(gridDEM$coords.x1,xMean,xSd)
gridDEM$Y <- zTransCoord(gridDEM$coords.x2,yMean,ySd)
makeTrendPolyForm <- function(baseForm=Z~1, coordForm=~X+Y, shpDf=NULL, polyDeg=1){
if (missing(baseForm) || class(baseForm) != "formula") stop("'baseForm' missing or incorrect")
if (missing(coordForm) || class(coordForm) != "formula" || length(all.vars(coordForm)) != 2)
stop("'coordForm' missing or incorrect")
if (as.integer(polyDeg) < 1L ) stop("'polyDeg' needs to be integer of 1 or above")
## shpDf declare check input variables
if (!is.null(shpDf)){
if (class(try(model.frame(baseForm, shpDf), T)) != "data.frame") stop("Incorrect variables in 'baseFrom'")
if (class(try(model.frame(coordForm, shpDf), T)) != "data.frame") stop("Incorrect variables in 'coordFrom'")
}
## Build string with the trend-surface coordinates
expo <- expand.grid(0L:polyDeg, 0L:polyDeg)
expo <- expo[rowSums(expo) <= polyDeg, ]    # make sure only terms up to polyDeg enter the formula
expo <- expo[-1,]                           # exclude x^0*y^0
expo <- expo[order(rowSums(expo)), ]        # make sure formula is sorted by the degree of the polynomial
formStr <- "~ ."
xy <- all.vars(coordForm)
for (i in 1: nrow(expo)) {
formStr <- paste(formStr, " + I(",xy[1],"^",expo[i,1],"*",xy[2],"^",expo[i,2],")", sep="")
}
## Merge covariate and polynomial formulas
polyForm <- update(baseForm,as.formula(formStr))
return(polyForm)
} #end::makeTrendPolyForm
polyForm1 <- makeTrendPolyForm(ELEVATION~RIVERDIST+I(RIVERDIST^2), ~X+Y, shpDf=samplePoints, polyDeg=1)
lmTrend1 <- lm(polyForm1, data=samplePoints)
summary(lmTrend1)
polyForm2 <- makeTrendPolyForm(ELEVATION~RIVERDIST+I(RIVERDIST^2), ~X+Y, shpDf=samplePoints, polyDeg=2)
lmTrend2 <- lm(polyForm2, data=samplePoints)
summary(lmTrend2)
anova(lmTrend1,lmTrend2)
polyForm3 <- makeTrendPolyForm(ELEVATION~RIVERDIST, ~X+Y, shpDf=samplePoints, polyDeg=3)
lmTrend3 <- lm(polyForm3, data=samplePoints)
summary(lmTrend3)
car::vif(lmTrend3)
anova(lmTrend2,lmTrend3)
par(mfrow = c(1,3))
model_lst = list(lmTrend1,lmTrend2,lmTrend3)
break_lst <- list()
for (i in 1:3){
predTrend <- predict(model_lst[[i]], gridDEM, se.fit = TRUE)
predFit <- predTrend$fit
predHist <- hist(predFit,freq=F,main= paste("Predicted DEM",i,"Order Trend"))
break_lst[[i]] <- predHist$breaks
}
par(mfrow = c(3,1))
for (i in 1:3){
predTrend <- predict(model_lst[[i]], gridDEM, se.fit = TRUE)
predFit <- predTrend$fit
breakptsPred <- break_lst[[i]]
nclPred <- length(breakptsPred)-1                                                   # Number of classes
palPred <- terrain.colors(nclPred)                                                  # get colors
colsPred <- palPred[findInterval(predFit,
breakptsPred,rightmost.closed=T)]                    # assign appropriate color to each residual
plot(gridDEM, axes=T, col=colsPred, pch=15,cex=1)
plot(river,col="blue",add=T)
title(paste("Predicted ", i, "Order DEM Surface"))
}
par(mfrow = c(1,2))
predTrend3 <- predict(lmTrend3, gridDEM, se.fit = TRUE)
predFit <- predTrend3$fit
predHist <- hist(predFit,freq=F,main="Predicted DEM 3rd Order Trend")
originHist <- hist(grid.data$ELEVATION,freq=F,main="Observed DEM Trend")
obsElev <- gridDEM$ELEVATION
plot(obsElev,predFit,pch=".")  ## note granularity of observed elevation
title(main="Observed against Predicted Elevations")
abline(a=0,b=1)
summary(predFit)
summary(grid.data$ELEVATION)
e1071::skewness(predFit) ; e1071::skewness(grid.data$ELEVATION)
e1071::kurtosis(predFit) ; e1071::kurtosis(grid.data$ELEVATION)
t.test(predFit,grid.data$ELEVATION)
library(classInt)
predSe.3 <- predTrend3$se.fit
n.col <- 6
pal <- brewer.pal(n.col,"Oranges")
seClass <- classIntervals(predSe.3, n.col, style="equal")
seCol <- findColours(seClass,pal)
plot(gridDEM,axes=T,col=seCol,pch=15,cex=2,
main="Prediction Standard Error: 3rd Order Trendsurface")
plot(river,col="blue",add=T)
legend("topleft", title = "Std.Erros",
legend = leglabs(round(seClass$brks, digits = 0)), fill = pal, bty = "o", ncol = 1)
pred.res <- gridDEM$ELEVATION-predTrend3$fit
n.col <- 5
pal <- rev(brewer.pal(n.col,"RdBu"))
seClass <- classIntervals(pred.res, n.col, style="equal")
seCol <- findColours(seClass,pal)
plot(gridDEM,axes=T,col=seCol,pch=15,cex=2,main="3rd Order Trend residual surface")
plot(river,col="blue",add=T)
legend("topleft", title = "Residual",
legend = leglabs(round(seClass$brks, digits = 0)), fill = pal,bty = "o", ncol = 1)
library(gstat)
samplePoints$sampleRes <- residuals(lmTrend3)     # add residuals to sampleDEM
gPred <- gstat(id="simKrig", formula=sampleRes~1, beta=0, data=samplePoints)
## Select final variogram for simple kriging of residuals
varioFinal <- variogram(gPred, cutoff=150000, width=2000) # alternative: variogram(sampleRes~1,sampleDEM)
varioFit <- fit.variogram(varioFinal,model=vgm(model="Exp",range=150000,nugget=500))
plot(varioFinal,model=varioFit)
varioFit
cat("Global variance is",var(samplePoints$sampleRes))
## Predict the residuals
gPred <- gstat(id="simKrig",gPred, model=varioFit)
predSimKrig <- predict(gPred, model=varioFit, newdata=gridDEM) # alternative: krige(sampleRes~1,sampleDEM, gridDEM, model=varioFit)
## Predicted Kriging residuals
predRes <- predSimKrig$simKrig.pred      # Kriging cell residual prediction
hist(predRes)
biPolarColorRamp <- function(varName,pos.breaks=4,neg.breaks=pos.breaks) {
require(RColorBrewer); require(classInt)
## define breaks and color assignment
q.neg.breaks <- classIntervals((varName[varName < 0]), n=neg.breaks, style="quantile")
q.pos.breaks <- classIntervals((varName[varName > 0]), n=pos.breaks, style="quantile")
qBreaks <- c(q.neg.breaks$brks[-(neg.breaks+1)],0,q.pos.breaks$brks[-1])     # combine neg and pos over zero
pal.neg <- brewer.pal(neg.breaks, "Blues")
pal.pos <- brewer.pal(pos.breaks, "Reds")
colPal <- c(rev(pal.neg),pal.pos)                                                # combine palettes
mapCol <- colPal[findInterval(varName,qBreaks,rightmost.closed=T)]
return(list(mapCol=mapCol,qBreaks=qBreaks,colPal=colPal))
} # end:biPolarColorRamp
library(RColorBrewer)
colRamp <- biPolarColorRamp(predRes, pos.breaks=4)
plot(gridDEM, axes=T, col=colRamp$mapCol, pch=15, cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="green",add=T)
legend("topright", title="Residuals", legend=leglabs(round(colRamp$qBreaks,2)),
fill=colRamp$colPal, bg="white",ncol=1)
title("Predicted Simple Kriging Residuals")
## Map kriging prediciton standard error
seRes <- sqrt(predSimKrig$simKrig.var)       # Standard errors of Kriging Residuals
seHist<- hist(seRes)
breakptsSe <- seHist$breaks
nclSe <- length(breakptsSe)-1
palSe <- rev(heat.colors(nclSe))
colsSe <- palSe[findInterval(seRes,
breakptsSe,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsSe, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="green",pch = 18,add=T)
legend("topright", title="Predicted DEM",legend=leglabs(round(breakptsSe,2)),
fill=palSe,bg="white",ncol=1)
title("Standard Errors of Kriging Residuals")
fitTot <- predFit+predRes                          # Total predicted cell value
seTot <- sqrt(predSe.3^2+predSimKrig$simKrig.var)    # Total cell prediction standard error
## Map overall prediciton surface
fitHist<- hist(fitTot,freq=F)
lines(density(gridDEM$ELEVATION),col="red",lwd=2)
breakptsFit <- fitHist$breaks
nclFit <- length(breakptsFit)-1
palFit <- terrain.colors(nclFit)
colsFit <- palFit[findInterval(fitTot,
breakptsFit,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsFit, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="red",add=T)
legend("topright", title="Predicted DEM",legend=leglabs(round(breakptsFit,2)),
fill=palFit,bg="white",ncol=1)
title("Prediction Surface: Trend (3rd) plus Kriging Residuals")
## Map overall prediciton standard error
seHist<- hist(seTot)
breakptsSe <- seHist$breaks
nclSe <- length(breakptsSe)-1
palSe <- rev(heat.colors(nclSe))
colsSe <- palSe[findInterval(seTot,
breakptsSe,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsSe, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="red",add=T)
legend("topright", title="Prediction STD. Error",legend=leglabs(round(breakptsSe,2)),
fill=palSe,bg="white",ncol=1)
title("Prediction Standard Errors of 3rd Order DEM Surface plus Kriging Residuals")
predError <- gridDEM$ELEVATION - fitTot
(RMSETotal <- sqrt(sum(predError^2)/length(predError)))
n.col <- 5
pal <- rev(brewer.pal(n.col,"RdBu"))
seClass <- classIntervals(predError, n.col, style="equal")
seCol <- findColours(seClass,pal)
plot(gridDEM,axes=T,col=seCol,pch=15,cex=2,
main="3rd Order Trend residual surface")
plot(river,col="blue",add=T)
legend("topleft", title = "Residual",
legend = leglabs(round(seClass$brks, digits = 0)), fill = pal, bty = "o", ncol = 1)
predFit <- predTrend3$fit
summary(predFit)
predHist <- hist(predFit,freq=F,main="Predicted DEM 3rd Order Trend")
breakptsPred <- predHist$breaks                                                     # Define Elevation classes
nclPred <- length(breakptsPred)-1                                                   # Number of classes
palPred <- terrain.colors(nclPred)                                                  # get colors
colsPred <- palPred[findInterval(predFit,
breakptsPred,rightmost.closed=T)]                    # assign appropriate color to each residual
plot(gridDEM, axes=T, col=colsPred, pch=15,cex=1)                                   # Observed DEM Grid
plot(river,col="blue",add=T)
title("Predicted 3rd Order DEM Surface\nIncorporating Distance to Rivers")
## Model Variograms
vgm()  # vgm models in gstat
show.vgms()
sampleDEM$sampleRes <- residuals(lmTrend3)     # add residuals to sampleDEM
library(gstat)
samplePoints$sampleRes <- residuals(lmTrend3)     # add residuals to sampleDEM
gPred <- gstat(id="simKrig", formula=sampleRes~1, beta=0, data=samplePoints)
## Select final variogram for simple kriging of residuals
varioFinal <- variogram(gPred, cutoff=150000, width=2000) # alternative: variogram(sampleRes~1,sampleDEM)
varioFit <- fit.variogram(varioFinal,model=vgm(model="Mat",range=150000,nugget=50))
plot(varioFinal,model=varioFit)
library(gstat)
samplePoints$sampleRes <- residuals(lmTrend3)     # add residuals to sampleDEM
gPred <- gstat(id="simKrig", formula=sampleRes~1, beta=0, data=samplePoints)
## Select final variogram for simple kriging of residuals
varioFinal <- variogram(gPred, cutoff=150000, width=2000) # alternative: variogram(sampleRes~1,sampleDEM)
varioFit <- fit.variogram(varioFinal,model=vgm(model="Mat",range=150000,nugget=50))
plot(varioFinal,model=varioFit)
varioFit
cat("Global variance is",var(samplePoints$sampleRes))
hscat(sampleRes~1, data=sampleDEM, (0:8)*10000)
## Explore instationary variogram
hscat(sampleRes~1, data=samplePoints, (0:8)*10000)         # explore correlation in distance bands
## Predict the residuals
gPred <- gstat(id="simKrig",gPred, model=varioFit)
predSimKrig <- predict(gPred, model=varioFit, newdata=gridDEM) # alternative: krige(sampleRes~1,sampleDEM, gridDEM, model=varioFit)
## Predicted Kriging residuals
predRes <- predSimKrig$simKrig.pred      # Kriging cell residual prediction
hist(predRes)
biPolarColorRamp <- function(varName,pos.breaks=4,neg.breaks=pos.breaks) {
require(RColorBrewer); require(classInt)
## define breaks and color assignment
q.neg.breaks <- classIntervals((varName[varName < 0]), n=neg.breaks, style="quantile")
q.pos.breaks <- classIntervals((varName[varName > 0]), n=pos.breaks, style="quantile")
qBreaks <- c(q.neg.breaks$brks[-(neg.breaks+1)],0,q.pos.breaks$brks[-1])     # combine neg and pos over zero
pal.neg <- brewer.pal(neg.breaks, "Blues")
pal.pos <- brewer.pal(pos.breaks, "Reds")
colPal <- c(rev(pal.neg),pal.pos)                                                # combine palettes
mapCol <- colPal[findInterval(varName,qBreaks,rightmost.closed=T)]
return(list(mapCol=mapCol,qBreaks=qBreaks,colPal=colPal))
} # end:biPolarColorRamp
library(RColorBrewer)
colRamp <- biPolarColorRamp(predRes, pos.breaks=4)
plot(gridDEM, axes=T, col=colRamp$mapCol, pch=15, cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="green",add=T)
legend("topright", title="Residuals", legend=leglabs(round(colRamp$qBreaks,2)),
fill=colRamp$colPal, bg="white",ncol=1)
title("Predicted Simple Kriging Residuals")
## Map kriging prediciton standard error
seRes <- sqrt(predSimKrig$simKrig.var)       # Standard errors of Kriging Residuals
seHist<- hist(seRes)
breakptsSe <- seHist$breaks
nclSe <- length(breakptsSe)-1
palSe <- rev(heat.colors(nclSe))
colsSe <- palSe[findInterval(seRes,
breakptsSe,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsSe, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="green",pch = 18,add=T)
legend("topright", title="Predicted DEM",legend=leglabs(round(breakptsSe,2)),
fill=palSe,bg="white",ncol=1)
title("Standard Errors of Kriging Residuals")
## Map kriging prediciton standard error
seRes <- sqrt(predSimKrig$simKrig.var)       # Standard errors of Kriging Residuals
seHist<- hist(seRes)
breakptsSe <- seHist$breaks
nclSe <- 5
palSe <- rev(heat.colors(nclSe))
colsSe <- palSe[findInterval(seRes,
breakptsSe,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsSe, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="green",pch = 18,add=T)
legend("topright", title="Predicted DEM",legend=leglabs(round(breakptsSe,2)),
fill=palSe,bg="white",ncol=1)
title("Standard Errors of Kriging Residuals")
## Map kriging prediciton standard error
seRes <- sqrt(predSimKrig$simKrig.var)       # Standard errors of Kriging Residuals
seHist<- hist(seRes)
breakptsSe <- seHist$breaks
nclSe <- length(breakptsSe)-1
palSe <- rev(heat.colors(nclSe))
colsSe <- palSe[findInterval(seRes,
breakptsSe,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsSe, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="green",pch = 18,add=T)
legend("topright", title="Predicted DEM",legend=leglabs(round(breakptsSe,2)),
fill=palSe,bg="white",ncol=1)
title("Standard Errors of Kriging Residuals")
## Map kriging prediciton standard error
seRes <- sqrt(predSimKrig$simKrig.var)       # Standard errors of Kriging Residuals
seHist<- hist(seRes)
breakptsSe <- seHist$breaks
nclSe <- length(breakptsSe)-1
palSe <- rev(heat.colors(nclSe))
colsSe <- palSe[findInterval(seRes,
breakptsSe,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsSe, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="green",pch = 5,add=T)
legend("topright", title="Predicted DEM",legend=leglabs(round(breakptsSe,2)),
fill=palSe,bg="white",ncol=1)
title("Standard Errors of Kriging Residuals")
fitTot <- predFit+predRes                          # Total predicted cell value
seTot <- sqrt(predSe.3^2+predSimKrig$simKrig.var)    # Total cell prediction standard error
## Map overall prediciton surface
fitHist<- hist(fitTot,freq=F)
lines(density(gridDEM$ELEVATION),col="red",lwd=2)
breakptsFit <- fitHist$breaks
nclFit <- length(breakptsFit)-1
palFit <- terrain.colors(nclFit)
colsFit <- palFit[findInterval(fitTot,
breakptsFit,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsFit, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="red",add=T)
legend("topright", title="Predicted DEM",legend=leglabs(round(breakptsFit,2)),
fill=palFit,bg="white",ncol=1)
title("Prediction Surface: Trend (3rd) plus Kriging Residuals")
## Map overall prediciton standard error
seHist<- hist(seTot)
breakptsSe <- seHist$breaks
nclSe <- length(breakptsSe)-1
palSe <- rev(heat.colors(nclSe))
colsSe <- palSe[findInterval(seTot,
breakptsSe,rightmost.closed=T)]
plot(gridDEM, axes=T, col=colsSe, pch=15,cex=1)
plot(river,col="blue",add=T)
plot(samplePoints,col="red",add=T)
legend("topright", title="Prediction STD. Error",legend=leglabs(round(breakptsSe,2)),
fill=palSe,bg="white",ncol=1)
title("Prediction Standard Errors of 3rd Order DEM Surface plus Kriging Residuals")
predError <- gridDEM$ELEVATION - fitTot
(RMSETotal <- sqrt(sum(predError^2)/length(predError)))
predError <- gridDEM$ELEVATION - fitTot
(RMSETotal <- sqrt(sum(predError^2)/length(predError)))
n.col <- 5
pal <- rev(brewer.pal(n.col,"RdBu"))
seClass <- classIntervals(predError, n.col, style="equal")
seCol <- findColours(seClass,pal)
plot(gridDEM,axes=T,col=seCol,pch=15,cex=2,
main="Prediciton Error of 3rd Order Trends with Kriging Residuals Model")
plot(river,col="blue",add=T)
legend("topleft", title = "Prediction Error",
legend = leglabs(round(seClass$brks, digits = 0)), fill = pal, bty = "o", ncol = 1)
summary(pred.res)
summary(predError)
(RMSETrend <- sqrt(sum(predError^2)/length(predError)))
## Root Mean Square Error
predError <- gridDEM$ELEVATION - predFit
(RMSETrend <- sqrt(sum(predError^2)/length(predError)))
## Evaluated Prediction Error
predError <- gridDEM$ELEVATION - fitTot
(RMSETotal <- sqrt(sum(predError^2)/length(predError)))
