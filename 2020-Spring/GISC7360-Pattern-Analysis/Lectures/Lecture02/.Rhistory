R2xtObs1 <- c(R2xtObs1,R2xtRand)
if (R2xtRand >= R2xtObs) {nxtrm <- nxtrm+1}
}
pval <- nxtrm/(NR+1)
hist(R2xtObs1,breaks = 25,freq = F)
lines(density(R2xtObs1,bw = ),col = 'blue',lwd = 1)
abline(v=R2xtObs,col="red")
return(c(R2xtObs, pval))
}
windrad <- winddeg*2*pi/360
R2xtIndTestRand(ozone, windrad, 9999)
## Calculate R-square of two circular datasets using variances and co-variances
R2xtCorrCoeff <- function(lvar, cvar) {
rxc <- cor(lvar, cos(cvar)) ; rxs <- cor(lvar, sin(cvar))
rcs <- cor(cos(cvar), sin(cvar))
R2xtVal <- ((rxc*rxc)+(rxs*rxs)-(2*rxc*rxs*rcs))/(1-rcs*rcs)
return(R2xtVal)
}
## Do 'NR' times sampling, and calculate the R-square for each samle.
## Get the p-value using their rank
R2xtIndTestRand <- function(lvar, cvar, NR) {
R2xtObs <- R2xtCorrCoeff(lvar, cvar)
R2xtObs1 <- c(R2xtObs) ; nxtrm <- 1
for (r in 1:NR) {
lvarRand <- sample(lvar)
R2xtRand <- R2xtCorrCoeff(lvarRand,cvar)
R2xtObs1 <- c(R2xtObs1,R2xtRand)
if (R2xtRand >= R2xtObs) {nxtrm <- nxtrm+1}
}
pval <- nxtrm/(NR+1)
hist(R2xtObs1,breaks = 25,freq = F)
lines(density(R2xtObs1,bw = ),col = 'blue',lwd = 1)
abline(v=R2xtObs,col="red")
return(c(R2xtObs, pval))
}
windrad <- winddeg*2*pi/360
R2xtIndTestRand(ozone, windrad, 9999)
load("G:/UTD_Classes/2020Spring/GISC7360_Pattern_Analysis/Lab01/LungDf.RData")
boxplot(lungDf$monthNum)
lungDf$monthNum
View(lungDf)
View(lungDf)
boxplot(lungDeath~monthNum,data=lungDf, main="Car Milage Data",
xlab="Number of Cylinders", ylab="Miles Per Gallon")
lungDf$season %>%
group_by(lungDf$monthNum) %>%
filter(any(lungDf$monthNum <= 3))
library("dplyr")
lungDf$season %>%
group_by(lungDf$monthNum) %>%
filter(any(lungDf$monthNum <= 3))
group_by(lungDf$monthNum)
lungDf$monthNum
boxplot(lungDeath~c(monthNum[monthNum<=3],monthNum[monthNum>=9]),data=lungDf, main="Car Milage Data",
xlab="Number of Cylinders", ylab="Miles Per Gallon")
filter(any(lungDf$monthNum <= 3))
lungDf$monthNum <= 3
any(lungDf$monthNum <= 3)
filter(lungDf$monthNum <= 3)
boxplot(lungDeath~monthNum,,data=lungDf, main="lung death against month",
xlab="Month", ylab="Death")
lungDf$monthNum
boxplot(lungDeath~monthNum,data=lungDf, main="lung death against month",
xlab="Month", ylab="Death")
summary(lm(lungDeath~monthNum,data=lungDf))
summary( mod<- lm(lungDeath~monthNum,data=lungDf))
amplitudeSe <- car::deltaMethod(mod, paste0("sqrt(",cosStr,"^2+",sinStr,"^2)"))
ampPhase <- function(mod, cosStr, sinStr, period){
#############################################################
## Objective: Calculates amplitude and phase shift based on
##            sin and cos terms. Evaluates standard errors
##            and confidence intervals by car::delta-method
## Input:
## mod        model object (lm or glm)
## cosStr     name of cos-term as string in the model object
## sinStr     name of sin-term as string in the model object
## period     numeric length of a full period in # of obs.
#############################################################
if ( !is.character(cosStr) ) stop("cosStr must be entered as string")
if ( !is.character(sinStr) ) stop("sinStr must be entered as string")
## Standard error of amplitude
amplitudeSe <- car::deltaMethod(mod, paste0("sqrt(",cosStr,"^2+",sinStr,"^2)"))
## Standard error of phase shift
atanStr <- paste0("atan(",sinStr,"/",cosStr,")")
if (mod$coefficients[cosStr] > 0 & mod$coefficients[sinStr] > 0)
phaseSe <- car::deltaMethod(mod, paste0(atanStr,"*",period,"/(2*pi)"))
if (mod$coefficients[cosStr] < 0)
phaseSe <- car::deltaMethod(mod, paste0("(",atanStr,"+pi)*",period,"/(2*pi)"))
if (mod$coefficients[cosStr] > 0 & mod$coefficients[sinStr] < 0)
phaseSe <- car::deltaMethod(mod,paste0("(",atanStr,"+2*pi)*",period,"/(2*pi)"))
fourierResult <- rbind(amplitudeSe,phaseSe)
row.names(fourierResult) <- c("Amplitude:","Phase Shift:")
return(fourierResult)
}
tapply(lungDf$lungDeath,lungDf$monthNum)
tapply(lungDf$lungDeath,lungDf$monthNum,mean)
tapply(lungDf$lungDeath,lungDf$monthNum,max)
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 3891              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
Mean(lungDf$lungDeath)
mean(lungDf$lungDeath)
avg <- 2145                     # overall average
## Parameters of 1st oscilation
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 3891              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2              # peak of the oscillation at the each phaseShift's observation
## Parameters of 2nd oscilation
lambda2 <- 1/6
amplitude2 <- 10
phaseShift2 <- 3
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
t
t <- lungDf$monthNum
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
if (twoOsc) yt <- yt + amplitude2 * cos(2*pi*lambda2*(t - phaseShift2))
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n")
ampPhase <- function(mod, cosStr, sinStr, period){
#############################################################
## Objective: Calculates amplitude and phase shift based on
##            sin and cos terms. Evaluates standard errors
##            and confidence intervals by car::delta-method
## Input:
## mod        model object (lm or glm)
## cosStr     name of cos-term as string in the model object
## sinStr     name of sin-term as string in the model object
## period     numeric length of a full period in # of obs.
#############################################################
if ( !is.character(cosStr) ) stop("cosStr must be entered as string")
if ( !is.character(sinStr) ) stop("sinStr must be entered as string")
## Standard error of amplitude
amplitudeSe <- car::deltaMethod(mod, paste0("sqrt(",cosStr,"^2+",sinStr,"^2)"))
## Standard error of phase shift
atanStr <- paste0("atan(",sinStr,"/",cosStr,")")
if (mod$coefficients[cosStr] > 0 & mod$coefficients[sinStr] > 0)
phaseSe <- car::deltaMethod(mod, paste0(atanStr,"*",period,"/(2*pi)"))
if (mod$coefficients[cosStr] < 0)
phaseSe <- car::deltaMethod(mod, paste0("(",atanStr,"+pi)*",period,"/(2*pi)"))
if (mod$coefficients[cosStr] > 0 & mod$coefficients[sinStr] < 0)
phaseSe <- car::deltaMethod(mod,paste0("(",atanStr,"+2*pi)*",period,"/(2*pi)"))
fourierResult <- rbind(amplitudeSe,phaseSe)
row.names(fourierResult) <- c("Amplitude:","Phase Shift:")
return(fourierResult)
}
avg <- mean(lungDf$lungDeath)
t <- lungDf$monthNum
ms <- length(lungDf$monthNum)
## Parameters of 1st oscilation
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 3891              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2              # peak of the oscillation at the each phaseShift's observation
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n")
plot(yt~t,type="b", lwd=2, xlim=c(0,13), xaxt="n")
plot(yt~t,type="b", lwd=2, xlim=c(0,12), xaxt="n")
plot(yt~t,type="b", lwd=2, xlim=c(0,15), xaxt="n")
plot(yt~t,type="b", lwd=2, xlim=c(0,13), xaxt="n")
rm(list=ls(all=TRUE))         # start clean
twoOsc <- FALSE               # allow for two overlapping oscilations
atanFnc <- FALSE              # evaluate atan functions
ampPhase <- function(mod, cosStr, sinStr, period){
#############################################################
## Objective: Calculates amplitude and phase shift based on
##            sin and cos terms. Evaluates standard errors
##            and confidence intervals by car::delta-method
## Input:
## mod        model object (lm or glm)
## cosStr     name of cos-term as string in the model object
## sinStr     name of sin-term as string in the model object
## period     numeric length of a full period in # of obs.
#############################################################
if ( !is.character(cosStr) ) stop("cosStr must be entered as string")
if ( !is.character(sinStr) ) stop("sinStr must be entered as string")
## Standard error of amplitude
amplitudeSe <- car::deltaMethod(mod, paste0("sqrt(",cosStr,"^2+",sinStr,"^2)"))
## Standard error of phase shift
atanStr <- paste0("atan(",sinStr,"/",cosStr,")")
if (mod$coefficients[cosStr] > 0 & mod$coefficients[sinStr] > 0)
phaseSe <- car::deltaMethod(mod, paste0(atanStr,"*",period,"/(2*pi)"))
if (mod$coefficients[cosStr] < 0)
phaseSe <- car::deltaMethod(mod, paste0("(",atanStr,"+pi)*",period,"/(2*pi)"))
if (mod$coefficients[cosStr] > 0 & mod$coefficients[sinStr] < 0)
phaseSe <- car::deltaMethod(mod,paste0("(",atanStr,"+2*pi)*",period,"/(2*pi)"))
fourierResult <- rbind(amplitudeSe,phaseSe)
row.names(fourierResult) <- c("Amplitude:","Phase Shift:")
return(fourierResult)
}
##
## Build a periodic time series to explore its properties
## Remember: cos(0)=1, cos(pi/2)= 0, cos(pi)=-1 and cos(3*pi/2)=0
##
yrs <- 10                     # number of years
t <- seq(0, (yrs*12)-1, by=1) # monthly time index. Note: Jan=0 and Dec=11
avg <- 2145                     # overall average
## Parameters of 1st oscilation
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 3891              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2              # peak of the oscillation at the each phaseShift's observation
## Parameters of 2nd oscilation
lambda2 <- 1/6
amplitude2 <- 10
phaseShift2 <- 3
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
if (twoOsc) yt <- yt + amplitude2 * cos(2*pi*lambda2*(t - phaseShift2))
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n")
axis(1, at=c(0,12,24,36,48,60,72,84,96,108,120))
abline(h=avg, v=phaseShift1, lwd=1)                            # reference line
abline(h=c(avg-amplitude1,avg+amplitude1), col="green", lty=5) # amplitude
abline(v=c(0,12,24,36,48,60,72,84,96,108,120), lty=2, col="red")                # mark January of each year
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yCos2 <- cos(t*lambda2*2*pi)
ySin2 <- sin(t*lambda2*2*pi)
## Estimate model
yrs.lm <- lm(yt~yCos1+ySin1)
if (twoOsc) yrs.lm <- lm(yt~yCos1+ySin1+yCos2+ySin2)
summary(yrs.lm)
car::vif(yrs.lm)
boxplot(lungDeath~monthNum,data=lungDf, main="lung death against month",
xlab="Month", ylab="Death")
load("G:/UTD_Classes/2020Spring/GISC7360_Pattern_Analysis/Lab01/LungDf.RData")
boxplot(lungDeath~monthNum,data=lungDf, main="lung death against month",
xlab="Month", ylab="Death")
View(lungDf)
yrs <- 6
avg <- mean(lungDf$lungDeath)
t <- lungDf$monthNum
## Parameters of 1st oscilation
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 3891              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2              # peak of the oscillation at the each phaseShift's observation
## Parameters of 2nd oscilation
lambda2 <- 1/6
amplitude2 <- 500
phaseShift2 <- 3
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
if (T) yt <- yt + amplitude2 * cos(2*pi*lambda2*(t - phaseShift2))
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n")
yrs <- 6
avg <- mean(lungDf$lungDeath)
t <- seq(0, (yrs*12)-1, by=1)
## Parameters of 1st oscilation
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 3891              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2              # peak of the oscillation at the each phaseShift's observation
## Parameters of 2nd oscilation
lambda2 <- 1/6
amplitude2 <- 500
phaseShift2 <- 3
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
if (T) yt <- yt + amplitude2 * cos(2*pi*lambda2*(t - phaseShift2))
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n")
boxplot(lungDeath~monthNum,data=lungDf, main="lung death against month",
xlab="Month", ylab="Death")
lungDf$monthNum
summary( mod<- lm(lungDeath~monthNum,data=lungDf))
amplitudeSe <- car::deltaMethod(mod, paste0("sqrt(",cosStr,"^2+",sinStr,"^2)"))
mean(lungDf$lungDeath)
tapply(lungDf$lungDeath,lungDf$monthNum,max)
yrs <- 6
avg <- mean(lungDf$lungDeath)
t <- seq(0, (yrs*12)-1, by=1)
## Parameters of 1st oscilation
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 3000              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2              # peak of the oscillation at the each phaseShift's observation
## Parameters of 2nd oscilation
lambda2 <- 1/6
amplitude2 <- 1500
phaseShift2 <- 3
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
if (T) yt <- yt + amplitude2 * cos(2*pi*lambda2*(t - phaseShift2))
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n")
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yCos2 <- cos(t*lambda2*2*pi)
ySin2 <- sin(t*lambda2*2*pi)
## Estimate model
yrs.lm <- lm(yt~yCos1+ySin1)
if (twoOsc) yrs.lm <- lm(yt~yCos1+ySin1+yCos2+ySin2)
summary(yrs.lm)
lines(x = t,y = lungDf$lungDeath)
mean(lungDf$lungDeath)
yrs <- 6
avg <- mean(lungDf$lungDeath)
t <- seq(0, (yrs*12)-1, by=1)
## Parameters of 1st oscilation
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 1000              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2              # peak of the oscillation at the each phaseShift's observation
## Parameters of 2nd oscilation
lambda2 <- 1/6
amplitude2 <- 500
phaseShift2 <- 3
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
if (T) yt <- yt + amplitude2 * cos(2*pi*lambda2*(t - phaseShift2))
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n")
lines(x = t,y = lungDf$lungDeath)
lines(x = t,y = lungDf$lungDeath,lwd = 2 , col = 'blue')
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n",col = 'red')
lines(x = t,y = lungDf$lungDeath,lwd = 2 , col = 'blue')
boxplot(lungDeath~monthNum,data=lungDf, main="lung death against month",
xlab="Month", ylab="Death")
yrs <- 6
avg <- mean(lungDf$lungDeath)
t <- seq(0, (yrs*12)-1, by=1)
## Parameters of 1st oscilation
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 1000              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2              # peak of the oscillation at the each phaseShift's observation
## Parameters of 2nd oscilation
lambda2 <- 1/12
amplitude2 <- 200
phaseShift2 <- 3
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
if (T) yt <- yt + amplitude2 * cos(2*pi*lambda2*(t - phaseShift2))
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n",col = 'red')
lines(x = t,y = lungDf$lungDeath,lwd = 2 , col = 'blue')
boxplot(lungDeath~monthNum,data=lungDf, main="lung death against month",
xlab="Month", ylab="Death")
amplitudeSe <- car::deltaMethod(mod, paste0("sqrt(",cosStr,"^2+",sinStr,"^2)"))
mean(lungDf$lungDeath)
tapply(lungDf$lungDeath,lungDf$monthNum,max)
yrs <- 6
avg <- mean(lungDf$lungDeath)
t <- seq(0, (yrs*12)-1, by=1)
## Parameters of 1st oscilation
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 1000              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2              # peak of the oscillation at the each phaseShift's observation
## Parameters of 2nd oscilation
lambda2 <- 1/12
amplitude2 <- 200
phaseShift2 <- 12
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
if (T) yt <- yt + amplitude2 * cos(2*pi*lambda2*(t - phaseShift2))
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n",col = 'red')
lines(x = t,y = lungDf$lungDeath,lwd = 2 , col = 'blue')
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yCos2 <- cos(t*lambda2*2*pi)
ySin2 <- sin(t*lambda2*2*pi)
if (T) yrs.lm <- lm(yt~yCos1+ySin1+yCos2+ySin2)
summary(yrs.lm)
amplitudeSe <- car::deltaMethod(mod, paste0("sqrt(",cosStr,"^2+",sinStr,"^2)"))
yrs <- 6
avg <- mean(lungDf$lungDeath)
t <- seq(0, (yrs*12)-1, by=1)
## Parameters of 1st oscilation
lambda1 <- 1/12               # frequency for annual cycle consisting of 12 month
amplitude1 <- 1000              # annual up- and down-swing around the average, here zero
phaseShift1 <- 2              # peak of the oscillation at the each phaseShift's observation
## Parameters of 2nd oscilation
lambda2 <- 1/6
amplitude2 <- 200
phaseShift2 <- 12
## Function of oscillating time series with random error term
yt <- avg + amplitude1 * cos(2*pi*lambda1*(t - phaseShift1)) + rnorm(length(t),0,1)
if (T) yt <- yt + amplitude2 * cos(2*pi*lambda2*(t - phaseShift2))
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n",col = 'red')
lines(x = t,y = lungDf$lungDeath,lwd = 2 , col = 'blue')
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yCos2 <- cos(t*lambda2*2*pi)
ySin2 <- sin(t*lambda2*2*pi)
## Estimate model
if (T) yrs.lm <- lm(yt~yCos1+ySin1+yCos2+ySin2)
summary(yrs.lm)
boxplot(lungDeath~monthNum,data=lungDf, main="lung death against month",
xlab="Month", ylab="Death")
boxplot(lungDeath~monthNum,data=lungDf, main="lung death against month",
xlab="Month", ylab="Death")
summary(mod <- lm(lungDeath~monthNum,data=lungDf))
## Estimate model
if (T) yrs.lm <- lm(yt~yCos1+ySin1+yCos2+ySin2)
## Plot time series
plot(yt~t,type="b", lwd=2, xlim=c(0,yrs*12+1), xaxt="n",col = 'red')
lines(x = t,y = lungDf$lungDeath,lwd = 2 , col = 'blue')
plot(x = t,y = lungDf$lungDeath,lwd = 2 , col = 'blue')
plot(x = t,y = lungDf$lungDeath,lwd = 2 ,type = "l", col = 'blue')
yrs <- 6
t <- seq(0, (yrs*12)-1, by=1)
plot(x = t,y = lungDf$lungDeath,lwd = 2 ,type = "l", col = 'blue')
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yrs <- 6
t <- seq(0, (yrs*12)-1, by=1)
plot(x = t,y = lungDf$lungDeath,lwd = 2 ,type = "l", col = 'blue')
lambda1 <- 1/12
lambda2 <- 1/24
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yCos2 <- cos(t*lambda2*2*pi)
ySin2 <- sin(t*lambda2*2*pi)
## Estimate model
yrs.lm <- lm(yt~yCos1+ySin1+yCos2+ySin2)
yrs <- 6
t <- seq(0, (yrs*12)-1, by=1)
plot(x = t,y = lungDf$lungDeath,lwd = 2 ,type = "l", col = 'blue')
lambda1 <- 1/12
lambda2 <- 1/24
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yCos2 <- cos(t*lambda2*2*pi)
ySin2 <- sin(t*lambda2*2*pi)
## Estimate model
yrs.lm <- lm(lungDf$lungDeath~lungDf$monthNum + yCos1 + ySin1 + yCos2 + ySin2)
summary(yrs.lm)
yrs <- 6
t <- seq(0, (yrs*12)-1, by=1)
plot(x = t,y = lungDf$lungDeath,lwd = 2 ,type = "l", col = 'blue')
lambda1 <- 1/12
lambda2 <- 1/6
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yCos2 <- cos(t*lambda2*2*pi)
ySin2 <- sin(t*lambda2*2*pi)
## Estimate model
yrs.lm <- lm(lungDf$lungDeath~lungDf$monthNum + yCos1 + ySin1 + yCos2 + ySin2)
summary(yrs.lm)
yrs <- 6
t <- seq(0, (yrs*12)-1, by=1)
lambda1 <- 1/12
lambda2 <- 1/6
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yCos2 <- cos(t*lambda2*2*pi)
ySin2 <- sin(t*lambda2*2*pi)
## Estimate model
yrs.lm <- lm(lungDf$lungDeath~lungDf$monthNum + yCos1 + ySin1 + yCos2 + ySin2)
summary(yrs.lm)
library(MASS)
step.model <- stepAIC(yrs.lm, direction = "both",
trace = FALSE)
summary(step.model)
summary(yrs.lm)
summary(step.model)
Lines(x = t,y = predict(step.model),col = 'red')
lines(x = t,y = predict(step.model),col = 'red')
plot(x = t,y = lungDf$lungDeath,lwd = 2 ,type = "l", col = 'blue')
lines(x = t,y = predict(step.model),lwd = 2,col = 'red')
## Transform number of month to continuous
yrs <- 6
t <- seq(0, (yrs*12)-1, by=1)
## Set lambda paramter, larger lambda, shorter phase shift
lambda1 <- 1/12
lambda2 <- 1/6
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yCos2 <- cos(t*lambda2*2*pi)
ySin2 <- sin(t*lambda2*2*pi)
## Estimate model
yrs.lm <- lm(lungDf$lungDeath~lungDf$monthNum + yCos1 + ySin1 + yCos2 + ySin2)
summary(yrs.lm)
## Transform number of month to continuous
yrs <- 6
t <- seq(0, (yrs*12)-1, by=1)
## Set lambda paramter, larger lambda, shorter phase shift
lambda1 <- 1/12
lambda2 <- 1/6
## Generate time-dependent cos and sin proxy variable
yCos1 <- cos(t*lambda1*2*pi)
ySin1 <- sin(t*lambda1*2*pi)
yCos2 <- cos(t*lambda2*2*pi)
ySin2 <- sin(t*lambda2*2*pi)
## Estimate model
yrs.lm <- lm(lungDf$lungDeath~t + yCos1 + ySin1 + yCos2 + ySin2)
summary(yrs.lm)
library(MASS)
step.model <- stepBIC(yrs.lm, direction = "both",
trace = FALSE)
library(MASS)
step.model <- stepAIC(yrs.lm, direction = "both",
trace = FALSE)
summary(step.model)
plot(x = t,y = lungDf$lungDeath,lwd = 2 ,type = "l", col = 'blue')
lines(x = t,y = predict(step.model),lwd = 2,col = 'red')
plot(x = t,y = lungDf$lungDeath,lwd = 2 ,type = "l", col = 'blue',xlab = 'Month',y = 'Lung Death')
plot(x = t,y = lungDf$lungDeath,lwd = 2 ,type = "l", col = 'blue',xlab = 'Month',ylab = 'Lung Death')
lines(x = t,y = predict(step.model),lwd = 2,col = 'red')
