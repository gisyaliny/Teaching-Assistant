library(sp)
rm(list=ls())               # Clean objects from workspace
##
## Calculates: [a] Center of Gravity (triangle area weighted triangle centers)
##             [b] Area of polygon (may have negative sign)
## see algorithm at https://en.wikipedia.org/wiki/Polygon#Area_and_centroid
##
## Read shape-file
Shape <- rgdal::readOGR(dsn="G:\\UTD_Classes\\2020Spring\\GISC7360_Pattern_Analysis\\Lecture01\\BowTiePolyShape",
layer="BowTiePolyShape", integer64="warn.loss")
coord <- Shape@polygons[[1]]@Polygons[[1]]@coords
plot(Shape, axes=T, asp=1)
points(coord,col="orange",pch=20, cex=2)
points(coordinates(Shape),col="red",pch=1, cex=1.5) # red circle
box()
npts <-nrow(coord)
coord[1,] == coord[npts, ]                         # are start- and end-point coordinates identical?
coord <- coord[npts:1, ]                           # reorder the coordinate sequence
subCentArea <- matrix(NA, nrow = npts-1, ncol=3)   # 1:=xCentroid, 2:=yCentroid, 3:=Area
for (i in 1:(npts-1)){
subCentArea[i,1] <- coord[i,1] + coord[i+1,1]
subCentArea[i,2] <- coord[i,2] + coord[i+1,2]
subCentArea[i,3] <- (coord[i,1]*coord[i+1,2] - coord[i+1,1]*coord[i,2])
} # end::for
## Area: abs(Area) == Shape@polygons[[1]]@area
A <- sum(subCentArea[,3])/2                        # depending on direction may have wrong sign
cat("Area:", A)
## Center of Gravity: identical to Shape@polygons[[1]]@labpt
cX <- sum(subCentArea[,1]*subCentArea[,3])/(6*A)
cY <- sum(subCentArea[,2]*subCentArea[,3])/(6*A)
points(cbind(cX,cY), col="blue", pch=3, cex=2)            # blue cross
cbind(cX,cY)
coordinates(Shape)
library(sp)
rm(list=ls())               # Clean objects from workspace
##
## Read shape-file using maptools (old approach)
##
#Shape <- maptools::readShapePoly("E:\\Lectures2020\\GISC7360\\Lecture01\\Region.shp")
##
## Read shape-file using rgdal (new approach)
## Notes: [a] It uses the "*.prj" information; [b] Layers should not have the
##        extension "*.sph"; [c] long integers are converted by default to factors,
##        to avoid this set option integer64="warn.loss"
##
Shape <- rgdal::readOGR(dsn="G:\\UTD_Classes\\2020Spring\\GISC7360_Pattern_Analysis\\Lecture01\\RegionCityShape",
layer="Region", integer64="warn.loss")
## Plot Polygons
polyCol <- c("orange1","orange2","orange3","orange4")
plot(Shape, border="white", lwd=2, col=polyCol, axes=T)
box(lwd=2)
title("Problematic Shape Points and Area Layouts")
points(coordinates(Shape),col="red",pch=7, cex=1.5)       # centroids (center of gravity) as the are stored in shape file
regionSet <- unique(Shape$REGION)                         # get region IDs
cent.pts <- matrix(NA,nrow=length(regionSet), ncol=2)     # initialize arithmetic centroid based on shape points
for (i in regionSet) {
for (j in 1:length(Shape@polygons[[i]]@Polygons)){
points(Shape@polygons[[i]]@Polygons[[j]]@coords,pch=19,cex=0.7)     # map the shape points
if(j == 1) polyCoords <- Shape@polygons[[i]]@Polygons[[j]]@coords   # collect coordinates
else polyCoords <- rbind(polyCoords,Shape@polygons[[i]]@Polygons[[j]]@coords)
}
cent.pts[i,] <- colMeans(polyCoords)                   # calculate centroids from shape points
}
points(cent.pts,pch=10,cex=1.5,col="blue")               # and map the calculated centroids
regionSet
library(sp)
rm(list=ls(all=TRUE))               # Clean objects from workspace
## Read shape-file
Shape <- rgdal::readOGR(dsn="G:\\UTD_Classes\\2020Spring\\GISC7360_Pattern_Analysis\\Lecture01\\RegionCityShape",
layer="Region", integer64="warn.loss")
## Plot Polygons
polyCol <- c("orange1","orange4","orange3","orange2")
plot(Shape, border="grey", col=polyCol)
box()
title("Weighted Regional Means by City Size")
## Read Cities
City <- rgdal::readOGR(dsn="E:\\Lectures2020\\GISC7360\\Lecture01",
layer="Cities", integer64="warn.loss")
City <- rgdal::readOGR(dsn="G:\\UTD_Classes\\2020Spring\\GISC7360_Pattern_Analysis\\Lecture01\\RegionCityShape",
layer="Cities", integer64="warn.loss")
CityDf <- as.data.frame(City)                                       # get into dataframe
wgt <- (CityDf[,"POPULATION"]/max(CityDf[,"POPULATION"]))           # define circle area for mapping
wgt <- sqrt(wgt/pi)*6                                               # translate area into circle radius
n <- nrow(CityDf)                                                   # number of cities
points(City,pch=16,col="blue",cex=wgt)                              # map cities by their size
CityDf[,"REGION"] <- factor(CityDf[,"REGION"])                      # coerce into factor
## Arithmetic means
MeanX <- tapply(CityDf[,"coords.x1"],CityDf[,"REGION"],mean,simplify=F)
MeanY <- tapply(CityDf[,"coords.x2"],CityDf[,"REGION"],mean,simplify=F)
points(MeanX,MeanY,col="blue",pch=7,cex=1.5)                        # Marked plain mean by circle
## Calculate weighted means of city coordinates in each region
regionSet <- unique(CityDf[,"REGION"])                              # get region IDs
for (idxReg in regionSet){                                          # cycle over regions
City.id <- which(CityDf[,"REGION"] == idxReg)                     # get record IDs for particular region
## Weighted means (tapply does not work for function "weighted.mean)
x.w.mean <- weighted.mean(CityDf[City.id,4],CityDf[City.id,"POPULATION"],na.rm=TRUE)
y.w.mean <- weighted.mean(CityDf[City.id,5],CityDf[City.id,"POPULATION"],na.rm=TRUE)
points(x.w.mean,y.w.mean,col="red",pch=11,cex=1.5)                   # Marked weighted mean by cross
}
legend(locator(1),
legend=c("Weighted Mean","Plain Mean"),
col=c("red","blue"),
pch=c(11,7))
