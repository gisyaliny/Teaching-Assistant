??bcpower
A <- matrix(c(2,7,3,5,3,2),nrow = 3)
A
A <- matrix(c(2,3,3,7,5,2),nrow = 3)
A
B <- matrix(c(-1,4,3,2,8,9),nrow = 3)
A %*% inv(B)
B^-1
qr.solve(B) %*% B
t(B)
A %*% t(B)
A %*% t(A) + B %*% t(B)
diag(A %*% t(A) + B %*% t(B))
(A %*% t(A) + B %*% t(B))
diag(diag(A %*% t(A) + B %*% t(B)))
inverse.gaussian(A %*% t(A) + B %*% t(B))
(A %*% t(A) + B %*% t(B))^-1
crossprod(A)
crossprod(A) + crossprod(A,B)
solve(A %*% t(A) + B %*% t(B))
35 *11  / 265
solve(matrix(c(265/11,0,0,0,11,0,0,0,2764/53),nrow = 3))
det(solve(matrix(c(265/11,0,0,0,11,0,0,0,2764/53),nrow = 3)))
det(solve(A %*% t(A) + B %*% t(B)))
det(solve(matrix(c(314/11,0,0,0,11,0,0,0,18867/314),nrow = 3)))
det(matrix(c(11/314,0,0,0,1/11,0,0,0,314/18867),nrow = 3))
C <- matrix(c0,1,1,1,0,1,2,2,0),nrow = 3)
C <- matrix(c0,1,1,1,0,1,2,2,0),nrow = 3)
C <- matrix(c(0,1,1,1,0,1,2,2,0),nrow = 3)
C
t
t(A) %*% C %*% B
det(t(A) %*% C %*% B)
solve(t(A) %*% C %*% B)
det(solve(t(A) %*% C %*% B))
det(matrix)
-1/1054 * det(matrix(c(302,-142,-101,44),nrow = 2))
det(matrix(c(302,-142,-101,44),nrow = 2))
D <- matrix(c(12,8,2,65,52,29,71,56,27),nrow = 3)
D
solve(D)
det(solve(D))
det(diag(18,26/3,-2))
det(diag(c(18,26/3,-2),ncol = 3))
det(diag(c(18,26/3,-2),ncol = 3))
1/-312
library(tidyverse)
library(nycflights13)
sqrt(2) ^ 2 == 2
near(sqrt(2) ^ 2, 2)
.Machine$double.eps^0.5
data("flights")
flights %>% filter(arr_delay>=3*60)
flights %>% filter(dest %in% c('DFW','DAL'))
flights %>% filter(carrier %in% c('WN','AA'))
flights %>% filter(arr_delay > 2 * 60,(sched_arr_time - sched_dep_time) - air_time  > 30)
flights %>% filter(dep_delay > 1 * 60,arr_delay > 60 ,(sched_arr_time - sched_dep_time) - air_time  > 30)
flights %>% arrange(!is.na(flights))
?select
# everything() selects all variable. It is also useful in combination with other tidyselect operators.
flights %>% select(sched_arr_time,sched_dep_time,sched_dep_time)
??mutate
flights %>% filter(!is.na(arr_delay)) %>%
mutate(ranking = rank(arr_delay, ties.method = "min")) %>%
top_n(10)
flights %>% filter(!is.na(arr_delay)) %>%
mutate(ranking = min_rank(arr_delay)) %>%
top_n(10)
flights %>% group_by(carrier) %>%
summarise(avg_dep_delay = mean(dep_delay[!is.na(dep_delay)]),
avg_arr_delay = mean(arr_delay[!is.na(arr_delay)]))
flights %>% filter(dep_delay > 0) %>%
group_by(hour) %>%
summarise(avg_delay = mean(dep_delay),happend_times =n())
w %>% x %>% y %>% z
library(TexMix)
data("tractShp")
tractDf <- as.data.frame(tractShp)
sapply(tractDf,is.factor)
summary(tractDf)
library(ggplot2)
library(reshape2)
tractDf %>% is.na() %>%
melt() %>%
ggplot(aes(x = Var2,y = Var1,fill=value)) +
geom_raster() +
coord_flip()+
scale_y_continuous(NULL, expand = c(0,0)) +
scale_fill_grey(name = '',labels = c("Present",'Missing'))+
xlab('Observation') +
theme(axis.text.y = element_text(size = 4))
library(ggplot2)
library(reshape2)
tractDf %>% is.na() %>%
melt() %>%
ggplot(aes(x = Var2,y = Var1,fill=value)) +
geom_raster() +
coord_flip()+
scale_y_continuous(NULL, expand = c(0,0)) +
scale_fill_grey(name = '',labels = c("Present",'Missing'))+
xlab('Observation') +
theme(axis.text.y = element_text(size = 4))
tractDf %>% is.na() %>%
melt() %>%
ggplot(aes(x = Var2,y = Var1,fill=value)) +
geom_raster() +
coord_flip()+
scale_y_continuous(NULL, expand = c(0,0)) +
scale_fill_grey(name = '',labels = c("Present",'Missing'))+
xlab('Observation') +
theme(axis.text.y = element_text(size = 4))
library(ggplot2)
library(reshape2)
tractDf %>% is.na() %>%
melt() %>%
ggplot(aes(x = Var1,y = Var2,fill=value)) +
geom_raster() +
coord_flip()+
scale_y_continuous(NULL, expand = c(0,0)) +
scale_fill_grey(name = '',labels = c("Present",'Missing'))+
xlab('Observation') +
theme(axis.text.y = element_text(size = 4))
tractDf %>% is.na() %>%
melt()
library(ggplot2)
library(reshape2)
tractDf %>% is.na() %>%
melt() %>%
ggplot(aes(x = Var2,y = Var1,fill=value)) +
geom_raster() +
coord_flip()+
scale_y_continuous(NULL, expand = c(0,0)) +
scale_fill_grey(name = '',labels = c("Present",'Missing'))+
xlab('Observation') +
theme(axis.text.y = element_text(size = 4))
tractDf %>% is.na() %>%
melt() %>%
ggplot(aes(x = Var2,y = Var1,fill=value)) +
geom_raster() +
coord_flip()+
scale_y_continuous(NULL, expand = c(0,0)) +
scale_fill_grey(name = '',labels = c("Present",'Missing'))+
xlab('Observation') +
theme(axis.text.y = element_text(size = 4))
tractDf %>% is.na() %>%
llapply(sum)
tractDf %>% is.na() %>%
lapply(sum)
tractDf %>% is.na() %>%
apply(2,sum)
tractDf %>% is.na() %>%
apply(1,sum)
tractDf %>% is.na() %>%
apply(1,sum) %>%
table()
tractDf %>% is.na() %>%
melt() %>%
ggplot(aes(x = Var2,y = Var1,fill=value)) +
geom_raster() +
coord_flip()+
scale_y_continuous(NULL, expand = c(0,0)) +
scale_fill_grey(name = '',labels = c("Present",'Missing'))+
xlab('Observation') +
theme(axis.text.y = element_text(size = 4))
tractDf %>%
step_center(all_numeric())%>%
step_scale(all_numeric())
tractDf %>%
step_center(all_numeric())%>%
step_scale(all_numeric())
library(recipes)
tractDf %>%
step_center(all_numeric())%>%
step_scale(all_numeric())
library(recipes)
tractDf %>%
step_center(all_numeric(),-all_outcomes()) %>%
step_scale(all_numeric(),-all_outcomes())
?step_center
View(tractDf)
?tractDf
??tractDf
library(recipes)
rec <- recipe(PCTB2010 ~ .,data = tractDf)
rec %>%
step_center(all_numeric(),-all_outcomes()) %>%
step_scale(all_numeric(),-all_outcomes())
library(recipes)
rec <- recipe(PCTB2010 ~ .,data = tractDf)
rec %>%
step_center(all_numeric()) %>%
step_scale(all_numeric())
x <- function(w){w <- w+w}
x(5)
x <- function(w){return(w+w)}
x(5)
y <- x
car<- data("cars")
attach(cars)
attach(car)
car<- data("cars")
attach(car)
force(cars)
attach(cars)
View(cars)
summary(mod1 <- lm(speed~dist))
summary(mod1 <- lm(speed/4~dist/4))
summary(mod1 <- lm((speed/4) ~(dist/4)))
speed1 <- speed/ 4
dist1 <- dist /4
summary(mod1 <- lm(speed1 ~dist1))
data("cars")
attach(cars)
summary(mod1 <- lm(speed~dist))
speed1 <- speed/ 4
dist1 <- dist /4
summary(mod2 <- lm(speed1 ~dist1))
data(cars)
attach(cars)
mod1 <- lm(dist~speed)
summary(mod1)
speed1 <- c(speed,mean(speed))
dist1 <- c(dist,mean(dist))
mod2 <- lm(dist1~speed1)
summary(mod2)
summary(mod1)
dist1 <- c(dist,mean(dist)-1)
mod2 <- lm(dist1~speed1)
summary(mod2)
summary(mod1)
# 2a
speed1 <- c(speed,mean(speed))
dist1 <- c(dist,mean(dist)-10)
mod2 <- lm(dist1~speed1)
summary(mod2)
speed1 <- c(speed,mean(speed))
dist1 <- c(dist,mean(dist)-20)
mod3 <- lm(dist1~speed1)
summary(mod3)
summary(mod1)
summary(mod3)
speed1 <- c(speed,mean(speed))
dist1 <- c(dist,mean(dist)+20)
mod4 <- lm(dist1~speed1)
summary(mod4)
summary(mod1)
# 2a
speed1 <- c(speed,mean(speed))
dist1 <- c(dist,mean(dist))
# 2a
speed1 <- c(speed,max(speed))
# 2a
predict(mod1)
speed1 <- c(speed,max(speed))
dist1 <- c(dist,max(predict(mod1)))
mod2 <- lm(dist1~speed1)
summary(mod2)
# 2a
summary(mod1)
speed1 <- c(speed,mean(speed))
dist1 <- c(dist,max(predict(mod1)) + 30)
mod3 <- lm(dist1~speed1)
summary(mod3)
# 2b
summary(mod1)
y1 <- rnorm(100,mean=0, sd = 1)
y2 <- rnorm(50,mean=200, sd = 2)
x <- c(rep(0,100),rep(1,50))
y <- c(y1,y2)
mod1 <- lm(y~x)
summary(mod1)
pt(0.194,df=150)
2*(1-pt(0.194,df=150))
2*(1-pt(0.194,df=149))
(1-pt(4.187,12))
#################################################
## Script demonstrating the underlying principle
## of the Mahalanobis distance
#################################################
rm(list=ls())                          # Clear environment
oldpar <- par()                        # save default graphical parameters
if (!is.null(dev.list()["RStudioGD"])) # Clear plot window
dev.off(dev.list()["RStudioGD"])
cat("\014")                            # Clear the Console
#################################################
## Script demonstrating the underlying principle
## of the Mahalanobis distance
#################################################
rm(list=ls())                          # Clear environment
oldpar <- par()                        # save default graphical parameters
if (!is.null(dev.list()["RStudioGD"])) # Clear plot window
dev.off(dev.list()["RStudioGD"])
cat("\014")                            # Clear the Console
n <- 10                               # number of observations
mu <- rep(0,3)                        # mean of three variables
## Co-variance matrix
cMat <- matrix(c(1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0), nrow=3,ncol=3)
#cMat <- matrix(c(1.0,0.9,0.0,0.9,1.0,0.0,0.0,0.0,1.0), nrow=3,ncol=3)
## Simulate multivariate normal distribution with these parameters
cMat
x <- MASS::mvrnorm(n, mu, cMat, empirical=TRUE)
View(x)
colnames(x) <- c("X1","X2","X3")
rownames(x) <- paste("O",1:n, sep="")
View(x)
round(var(x),4)                       # empirical co-variance matrix
## Visualize the three variables
car::scatter3d(x[,1], x[,2], x[,3],
xlab="X1", ylab="X2", zlab="X3", surface=FALSE, residuals=FALSE)
## Caculate distance matrix with correlated variables
round(dCor <- dist(x, diag=TRUE, upper=TRUE), 2)
## Caculate distance matrix with uncorrelated variables, i.e., X2 dropped
round(dMaNo <- dist(x[, -2], diag=TRUE, upper=TRUE), 2)
## Principal Component Analysis
prX <- prcomp(x, retx=TRUE, center=TRUE, scale.=TRUE)
round(prX$sdev^2, 4)       # Eigenvalues
round(var(prX$x), 4)       # Evaluate co-variance of principal components
## Compared distance with correlated variables
round(PCdCor <- dist(prX$x[,1:2], diag=TRUE, upper=TRUE), 2)
## Compared distance with uncorrelated variables
pcScaled <- scale(prX$x[,1:2])
round(pcMaNo <- dist(pcScaled, diag=TRUE, upper=TRUE), 2)
all.equal(pcMaNo, dMaNo, check.attributes=FALSE)
rm(list=ls())                          # Clear environment
oldpar <- par()                        # save default graphical parameters
if (!is.null(dev.list()["RStudioGD"])) # Clear plot window
dev.off(dev.list()["RStudioGD"])
cat("\014")                            # Clear the Console
library(car); library(pls)
setwd("E:\\Lectures2021\\GISC6323\\Week08")
basin <- foreign::read.dta("basins.dta")
setwd("G:/UTD_Classes/Teaching-Assistant/2021-Spring/GISC-6323-Machine-Learning-for-Socio-Economic-and-Geo-Referenced-Data/Week8")
library(car); library(pls)
# setwd("E:\\Lectures2021\\GISC6323\\Week08")
basin <- foreign::read.dta("basins.dta")
scatterplotMatrix(~yield+runoff+precip+glacier+area, data=basin)
basin[,6] <- basin[,6] + 1              # glacier has-zeros. log wont work
basin[,3:7] <- log(basin[,3:7])         # perform log-transformation
scatterplotMatrix(~yield+runoff+precip+glacier+area, data=basin)
corBasin <- cor(basin[,3:6])            # correlation matrix
print(corBasin, digits=2)
##
## Principal component analysis on correlation matrix including component scores
##
?princomp # study online help
pcBasin <- princomp(~runoff+precip+glacier+area, data=basin, cor=TRUE, scores=TRUE)
summary(pcBasin, loadings=TRUE, cutoff=0.5)
apply(pcBasin$loadings^2,1,sum)         # row-sum of squared loadings
## Eigenvalues of each component, i.e., explained variances
round(pcBasin$sdev^2, 2)
## Component scores
( pcScores <- pcBasin$scores )          # observation value associated with each component
print(round(cor(pcScores), 2))          # uncorrelated component scores
apply(pcScores,2,var) * 18/19           # Each component has the eigenvalue as variance
## Descriptive plots
screeplot(pcBasin, type="lines")        # Scree graph Fig 8.4
abline(h=1,lty=2)
biplot(pcBasin)                         # unrotated components
abline(h=0,v=0, lty=5)
##
## Regression with First and Second Principal Components
##
org.lm <- lm(yield~runoff+precip+glacier+area, data=basin)
summary(org.lm)
vif(org.lm)
basinWithComp <- data.frame(basin, pcScores)
comp.lm <- lm(yield~Comp.1+Comp.2, data=basinWithComp)
summary(comp.lm)
summary(org.lm)
summary(comp.lm)
##
## Principal Component Regression
##
pcr.lm <- pcr(yield~runoff+precip+glacier+area, data=basin, scale=TRUE,
validation="CV", ncomp=4)
summary(pcr.lm)
validationplot(pcr.lm)
##
## Partial Least Squares Regression
##
plsr.lm <- plsr(yield~runoff+precip+glacier+area, data=basin, scale=TRUE,
validation="CV", ncomp=4)
summary(plsr.lm)
validationplot(plsr.lm)
summary(pcr.lm)
data(cars)
attach(cars)
mod1 <- lm(dist~speed)
summary(mod1)
P <- rnorm(50,mean = 10, sd = 2)
set.seed(2)
P <- rnorm(50,mean = 10, sd = 2)
speed1 <- speed/P
dist1 <- dist/P
mod2 <- lm(dist1~speed1)
summary(mod2)
summary(mod1)
mod3 <- lm(dist~speed+P)
summary(mod3)
mean(speed1)
mean(speed)
mean(speed)/ mean(P)
var(speed1)
cov(speed,P)
