install.packages(c("ClustGeo", "spdep"))
library(maptools); library(spdep); library(DallasTracts); library(ClustGeo)
rm(list=ls(all=T))
AdjOrder<- function(B){
##
## Generate higher order spatial link matrix and accumulate the order
##
## Input: B binary symmetric first order link matrix
B <- as.matrix(B)
n <- nrow(B)
H <- B
BB <- B
for (i in 2:n){
BB<- BB %*% B                        # power link matrix
S <- ((BB>0) & (H==0))               # logical matrix: first time i-steps apart
H <- H + i*S                         # label H cells by i-steps apart
if (min(BB) > 0 ) break              # reached diameter of of graph
} #end::for
diag(H)<- 0
return(H)
} #end::AdjOrder
data(tractShp)
validTractShp <- tractShp[!is.na(tractShp$BUYPOW), ]        # Remove 2 airport tracts with NA's
##
## Generate graph and spherical distance matrices
##
nb <- spdep::poly2nb(validTractShp, queen=F)                 # extract first order neighbors links
B <- spdep::nb2mat(nb, style="B")                            # convert neighbor list to binary matrix
stepDist <- AdjOrder(B)                                      # distance matrix of tracts i-steps apart
sphDist <- sp::spDists(validTractShp, longlat=T)             # spherical distance matrix among tracts in km
##
## Visulize first order neighbors
##
plot(validTractShp, col="palegreen3", border=grey(0.9), axes=T)
plot(nb, coords=coordinates(validTractShp), pch=19, cex=0.1, col="blue", add=T)
title("Spatial Neighbors Links among Tracts")
xVar <- as.data.frame(validTractShp@data)
View(xVar)
sapply(xVar[,1:ncol(xVar)],function(x){is.numeric(x)})
xVar[,sapply(xVar[,1:ncol(xVar)],function(x){is.numeric(x)})]
new_xVar<- xVar[,sapply(xVar[,1:ncol(xVar)],function(x){is.numeric(x)})]
View(new_xVar)
summary(new_xVar)
complete.cases(new_xVar)
View(xVar)
View(new_xVar)
library(DMwR)
install.packages("DMwR")
sapply(new_xVar[,colnames(new_xVar)],function(x),complete.cases(x))
sapply(new_xVar[,colnames(new_xVar)],function(x) complete.cases(x))
sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x)))
sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))
knnOutput <- knnImputation(BostonHousing[, !names(BostonHousing) %in% "medv"])
sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))
colnames(new_xVar)[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
missList<- colnames(new_xVar)[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
library(DMwR)
tractShp@data[,missList[1]]
??knnImputation
?knnImputation
knnOutput <- knnImputation(new_xVar[, !colnames(new_xVar) %in% "missList"])
knnOutput
knnOutput[,missList[1]]
new_xVar[,missList[1]]
new_xVar[,missList[1]][!is.na(new_xVar[,missList[1]])]
knnOutput[,missList[1]][!is.na(new_xVar[,missList[1]])]
View(knnOutput)
new_xVar <- scale(new_xVar)
knnOutput <- knnImputation(new_xVar[, !colnames(new_xVar) %in% "missList"])
knnOutput[,missList[1]][!is.na(new_xVar[,missList[1]])]
new_xVar[,missList[1]][!is.na(new_xVar[,missList[1]])]
View(knnOutput)
new_xVar <- scale(new_xVar[,-1])
knnOutput <- knnImputation(new_xVar[, !colnames(new_xVar) %in% "missList"])
View(knnOutput)
pc <-prcomp(new_xVar[,!colnames(new_xVar) %in% "missList"], retx=TRUE)
new_xVar[,!colnames(new_xVar) %in% "missList"]
pc <-prcomp(new_xVar[,-missList], retx=TRUE)
new_xVar[,-missList]
new_xVar[,-missList]
new_xVar[,missList]
missList
new_xVar[missList]
missList<- 1:colnames(new_xVar)[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
missList<- 1:ncol(new_xVar)[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
missList
missList<- seq(1:ncol(new_xVar))[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
missList
[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))
missList<- colnames(new_xVar)[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
missList
library(maptools); library(spdep); library(DallasTracts); library(ClustGeo)
rm(list=ls(all=T))
AdjOrder<- function(B){
##
## Generate higher order spatial link matrix and accumulate the order
##
## Input: B binary symmetric first order link matrix
B <- as.matrix(B)
n <- nrow(B)
H <- B
BB <- B
for (i in 2:n){
BB<- BB %*% B                        # power link matrix
S <- ((BB>0) & (H==0))               # logical matrix: first time i-steps apart
H <- H + i*S                         # label H cells by i-steps apart
if (min(BB) > 0 ) break              # reached diameter of of graph
} #end::for
diag(H)<- 0
return(H)
} #end::AdjOrder
data(tractShp)
validTractShp <- tractShp[!is.na(tractShp$BUYPOW), ]        # Remove 2 airport tracts with NA's
##
## Generate graph and spherical distance matrices
##
nb <- spdep::poly2nb(validTractShp, queen=F)                 # extract first order neighbors links
B <- spdep::nb2mat(nb, style="B")                            # convert neighbor list to binary matrix
stepDist <- AdjOrder(B)                                      # distance matrix of tracts i-steps apart
sphDist <- sp::spDists(validTractShp, longlat=T)             # spherical distance matrix among tracts in km
### find the numeric variable
xVar <- as.data.frame(validTractShp@data)
new_xVar<- xVar[,sapply(xVar[,1:ncol(xVar)],function(x){is.numeric(x)})]
### Principal component analysis
library(DMwR)
missList<- colnames(new_xVar)[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
### get rid of ID and missing value line
new_xVar <- scale(new_xVar[,-1])
missList
colnames(new_xVar) %in% "missList"
colnames(new_xVar) %in% missList
index <- 1:ncol(new_xVar)[colnames(new_xVar) %in% missList]
1:ncol(new_xVar)
index <- c(1:ncol(new_xVar))[colnames(new_xVar) %in% missList]
index
library(maptools); library(spdep); library(DallasTracts); library(ClustGeo)
rm(list=ls(all=T))
AdjOrder<- function(B){
##
## Generate higher order spatial link matrix and accumulate the order
##
## Input: B binary symmetric first order link matrix
B <- as.matrix(B)
n <- nrow(B)
H <- B
BB <- B
for (i in 2:n){
BB<- BB %*% B                        # power link matrix
S <- ((BB>0) & (H==0))               # logical matrix: first time i-steps apart
H <- H + i*S                         # label H cells by i-steps apart
if (min(BB) > 0 ) break              # reached diameter of of graph
} #end::for
diag(H)<- 0
return(H)
} #end::AdjOrder
data(tractShp)
validTractShp <- tractShp[!is.na(tractShp$BUYPOW), ]        # Remove 2 airport tracts with NA's
##
## Generate graph and spherical distance matrices
##
nb <- spdep::poly2nb(validTractShp, queen=F)                 # extract first order neighbors links
B <- spdep::nb2mat(nb, style="B")                            # convert neighbor list to binary matrix
stepDist <- AdjOrder(B)                                      # distance matrix of tracts i-steps apart
sphDist <- sp::spDists(validTractShp, longlat=T)             # spherical distance matrix among tracts in km
### find the numeric variable
xVar <- as.data.frame(validTractShp@data)
new_xVar<- xVar[,sapply(xVar[,1:ncol(xVar)],function(x){is.numeric(x)})]
### Principal component analysis
### get rid of ID and missing value line
new_xVar <- scale(new_xVar[,-1])
missList<- colnames(new_xVar)[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
index <- c(1:ncol(new_xVar))[colnames(new_xVar) %in% missList]
index
missList
library(maptools); library(spdep); library(DallasTracts); library(ClustGeo)
rm(list=ls(all=T))
AdjOrder<- function(B){
##
## Generate higher order spatial link matrix and accumulate the order
##
## Input: B binary symmetric first order link matrix
B <- as.matrix(B)
n <- nrow(B)
H <- B
BB <- B
for (i in 2:n){
BB<- BB %*% B                        # power link matrix
S <- ((BB>0) & (H==0))               # logical matrix: first time i-steps apart
H <- H + i*S                         # label H cells by i-steps apart
if (min(BB) > 0 ) break              # reached diameter of of graph
} #end::for
diag(H)<- 0
return(H)
} #end::AdjOrder
data(tractShp)
validTractShp <- tractShp[!is.na(tractShp$BUYPOW), ]        # Remove 2 airport tracts with NA's
##
## Generate graph and spherical distance matrices
##
nb <- spdep::poly2nb(validTractShp, queen=F)                 # extract first order neighbors links
B <- spdep::nb2mat(nb, style="B")                            # convert neighbor list to binary matrix
stepDist <- AdjOrder(B)                                      # distance matrix of tracts i-steps apart
sphDist <- sp::spDists(validTractShp, longlat=T)             # spherical distance matrix among tracts in km
### find the numeric variable
xVar <- as.data.frame(validTractShp@data)
new_xVar<- xVar[,sapply(xVar[,1:ncol(xVar)],function(x){is.numeric(x)})]
### Principal component analysis
### get rid of ID and missing value line
new_xVar <- scale(new_xVar[,-1])
missList<- colnames(new_xVar)[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
index <- c(1:ncol(new_xVar))[colnames(new_xVar) %in% missList]
missList
library(maptools); library(spdep); library(DallasTracts); library(ClustGeo)
rm(list=ls(all=T))
AdjOrder<- function(B){
##
## Generate higher order spatial link matrix and accumulate the order
##
## Input: B binary symmetric first order link matrix
B <- as.matrix(B)
n <- nrow(B)
H <- B
BB <- B
for (i in 2:n){
BB<- BB %*% B                        # power link matrix
S <- ((BB>0) & (H==0))               # logical matrix: first time i-steps apart
H <- H + i*S                         # label H cells by i-steps apart
if (min(BB) > 0 ) break              # reached diameter of of graph
} #end::for
diag(H)<- 0
return(H)
} #end::AdjOrder
data(tractShp)
validTractShp <- tractShp[!is.na(tractShp$BUYPOW), ]        # Remove 2 airport tracts with NA's
##
## Generate graph and spherical distance matrices
##
nb <- spdep::poly2nb(validTractShp, queen=F)                 # extract first order neighbors links
B <- spdep::nb2mat(nb, style="B")                            # convert neighbor list to binary matrix
stepDist <- AdjOrder(B)                                      # distance matrix of tracts i-steps apart
sphDist <- sp::spDists(validTractShp, longlat=T)             # spherical distance matrix among tracts in km
### find the numeric variable
xVar <- as.data.frame(validTractShp@data)
new_xVar<- xVar[,sapply(xVar[,1:ncol(xVar)],function(x){is.numeric(x)})]
### Principal component analysis
### get rid of ID and missing value line
missList<- colnames(new_xVar)[sapply(new_xVar[,colnames(new_xVar)],function(x) sum(complete.cases(x))< nrow(new_xVar))]
new_xVar <- scale(new_xVar[,-1])
index <- c(1:ncol(new_xVar))[colnames(new_xVar) %in% missList]
missList
index
View(new_xVar)
pc <-prcomp(new_xVar[,-index], retx=TRUE)
plot(pc$sdev^2, type="b", main="Scree Plot",
xlab="Component Order", ylab="Eigenvalue")
abline(h=1, v=c(3,7), lty=5,lwd=2, col="red")
plot(pc$sdev^2, type="b", main="Scree Plot",
xlab="Component Order", ylab="Eigenvalue")
abline(h=1, v=c(3,8), lty=5,lwd=2, col="red")
cumVar <- cumsum(xVars_pc$sdev^2)/length(xVars_pc$sdev)*100
plot(cumVar, main="Percent Explained Variance",
type="b", xlab="Component Order", ylab="Relative Cummulative Variance")
cumVar <- cumsum(pc$sdev^2)/length(pc$sdev)*100
plot(cumVar, main="Percent Explained Variance",
type="b", xlab="Component Order", ylab="Relative Cummulative Variance")
nofComp <- 8
cumVar <- cumsum(pc$sdev^2)/length(pc$sdev)*100
plot(cumVar, main="Percent Explained Variance",
type="b", xlab="Component Order", ylab="Relative Cummulative Variance")
abline(v=nofComp, h=cumVar[nofComp], lty=5)
View(pc)
pc[,1:8]
pc$x
pc <- cbind(pc$x[,1:8],new_xVar[,index])
pc
knnOutput <- knnImputation(pc)
knnOutput
cor(knnOutput)
cor.test(knnOutput)
cor(knnOutput)
pc1 <-prcomp(knnOutput, retx=TRUE)
pc1 <-prcomp(knnOutput, retx=TRUE)
plot(pc1$sdev^2, type="b", main="Scree Plot",
xlab="Component Order", ylab="Eigenvalue")
abline(h=1, v=c(3,8), lty=5,lwd=2, col="red")
# plot(pc1$sdev^2, type="b", main="Scree Plot",
#      xlab="Component Order", ylab="Eigenvalue")
# abline(h=1, v=c(3,8), lty=5,lwd=2, col="red")
nofComp <- 8
install.packages("ISLR")
install.packages("effects")
plot(validTractShp, col="palegreen3", border=grey(0.9), axes=T)
plot(nb, coords=coordinates(validTractShp), pch=19, cex=0.1, col="blue", add=T)
title("Spatial Neighbors Links among Tracts")
B
geoDist <- 1-B
diag(geoDist) <- 0
geoDist <- as.dist(geoDist)
cr <- choicealpha(pc1$x[1:nofComp], geoDist, range.alpha=seq(0, 1, 0.1), K=12, graph=TRUE)
cr <- choicealpha( geoDist, pc1$x[1:nofComp],range.alpha=seq(0, 1, 0.1), K=12, graph=TRUE)
featureDist <- dist(pc1$x[1:nofComp])
cr <- choicealpha(featureDist, geoDist, range.alpha=seq(0, 1, 0.1), K=12, graph=TRUE)
featureDist
pc1$x[1:nofComp]
pc1$x[,1:nofComp]
featureDist <- dist(pc1$x[,1:nofComp])
cr <- choicealpha(featureDist, geoDist, range.alpha=seq(0, 1, 0.1), K=12, graph=TRUE)
ree <- hclustgeo(featureDist, geoDist, alpha=0.3)
P12ter <- cutree(tree, 12)
tree <- hclustgeo(featureDist, geoDist, alpha=0.3)
P12ter <- cutree(tree, 12)
sp::plot(validTractShp, border="grey", col=P12ter)
P12ter
plot(validTractShp, border="grey", col=P12ter)
plot(validTractShp, border="grey", col=P12ter)
validTractShp$Type <- P12ter
mapColorQual(validTractShp$Type, validTractShp,
map.title="Auto Divition",
legend.title = "Regions",add.to.map=T)
validTractShp$Type
mapColorQual(validTractShp$Type, validTractShp,
map.title="Auto Divition",
legend.title = "Regions")
validTractShp$Type <- as.factor(P12ter)
mapColorQual(validTractShp$Type, validTractShp,
map.title="Auto Divition",
legend.title = "Regions",add.to.map=T)
