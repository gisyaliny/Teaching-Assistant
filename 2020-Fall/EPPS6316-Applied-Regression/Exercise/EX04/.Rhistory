z <- rep(c(1,2),3)
z
z <- rep(c(1,2),3)
z
library(foreign)
Concord <- read.spss('Concord1.sav', to.data.frame=TRUE)
library(foreign)
Concord <- read.spss('Concord1.sav', to.data.frame=TRUE)
library(AER);library(car);library(e1071)
data(CPS1985)
summary(powerTransform(CPS1985$wage~1))
par(mfrow = c(1,3))
hist(Concord$Z1.0.17,breaks = 12,main = paste('Water79 , Skewness =',round(e1071::skewness(Concord$Z1.0.17),2)),xlab = 'x')
par(mfrow = c(1,3))
hist(car::bcPower(CPS1985$wage, lambda=1),breaks = 12,main = 'lambda = 1',xlab = 'x')
hist(car::bcPower(CPS1985$wage, lambda= -0.0658 ),breaks = 12,main = 'lambda = -0.0658',xlab = 'x')
hist(car::bcPower(CPS1985$wage, lambda= -1.5 ),breaks = 12,main = 'lambda = -1.5',xlab = 'x')
par(mfrow = c(1,3))
hist(car::bcPower(CPS1985$wage, lambda=1),breaks = 12,main = 'lambda = 1',xlab = 'x')
hist(car::bcPower(CPS1985$wage, lambda= -0.0658 ),breaks = 12,main = 'lambda = -0.0658',xlab = 'x')
hist(car::bcPower(CPS1985$wage, lambda= -1.5 ),breaks = 12,main = 'lambda = -1.5',xlab = 'x')
summary(lm(wage~education, data=CPS1985))
summary(lm(income~education, data=CPS1985))
summary(lm(income~education, data=Concord))
summary(lm(income~education, data=Concord))
summary(lm(income~education, data=Concord))
summary(lm(income~education, data=Concord))
View(Concord)
library(foreign)
Concord <- read.spss('Concord1.sav', to.data.frame=TRUE)
summary(lm(income~education, data=Concord))
library(foreign)
Concord <- read.spss('Concord1.sav', to.data.frame=TRUE)
View(Concord)
library(foreign)
CPS1985 <- read.spss('CPS1985.dbf', to.data.frame=TRUE)
library(foreign)
CPS1985 <- read.dbf('CPS1985.dbf', to.data.frame=TRUE)
library(foreign)
CPS1985 <- read.dbf('CPS1985.dbf')
View(CPS1985)
View(Concord)
summary(lm(income~education, data=Concord))
summary(lm(income~educat, data=Concord))
reg <- lm(income~educat, data=Concord)
cbind("Coef"=coef(reg), confint(reg, level=0.99))
regPred <- predict(reg, interval="prediction", level = 0.90)
ConcordPred <- data.frame(Concord,regPred)
plot(income~educat,data=ConcordPred, main = "Point Prediction and Confidence Interval")
lines(ConcordPred$educat,ConcordPred$fit,col="red")
lines(ConcordPred$educat,ConcordPred$lwr,col="green")
lines(ConcordPred$educat,ConcordPred$upr,col="green")
abline(h=mean(ConcordPred$income), lty=3)
abline(v=mean(ConcordPred$educat), lty=3)
regPred <- predict(reg, interval="prediction", level = 0.90)
ConcordPred <- data.frame(Concord,regPred)
plot(income~educat,data=ConcordPred, main = "Point Prediction and Confidence Interval")
lines(ConcordPred$educat,ConcordPred$fit,col="red")
lines(ConcordPred$educat,ConcordPred$lwr,col="green")
lines(ConcordPred$educat,ConcordPred$upr,col="green")
abline(h=mean(ConcordPred$income), lty=3)
abline(v=mean(ConcordPred$educat), lty=3)
HPRICE2 <- foreign::read.dta('HPRICE2.DTA')
scatterplot(price ~ dist , data = HPRICE2)
HPRICE2 <- foreign::read.dta('HPRICE2.DTA')
scatterplot(price ~ dist , data = HPRICE2,pch=1, smooth=list(span = 0.35,lty.smooth=1, col.smooth="red", col.var="red"),regLine=list(col="green"))
## Transformation of independent variable
summary(powerTransform(lm(dist~1, data=HPRICE2)))
## Transformation of independent variable
summary(powerTransform(lm(dist~1, data=HPRICE2)))
## Transformation of dependent variable so residuals become approx. symmetric
summary(powerTransform((lm(price~log(dist), data=HPRICE2))))
## Transformation of dependent variable so residuals become approx. symmetric
summary(powerTransform((lm(price~log(dist), data=HPRICE2))))
## Estimate the elasticity model
elast.lm <- lm(log(price)~log(dist), data=HPRICE2)
summary(elast.lm)
## Test for H0: beta_log(crime)=1
slope <- coef(elast.lm)[2]
se <- summary(elast.lm)$coefficients[2, 2]
df <- nrow(crime) - 2
## Test for H0: beta_log(crime)=1
slope <- coef(elast.lm)[2]
se <- summary(elast.lm)$coefficients[2, 2]
df <- nrow(HPRICE2) - 2
(t.value <- (slope-1)/se) # Note E(slope)=1 under H0
## Test for H0: beta_log(crime)=1
slope <- coef(elast.lm)[2]
se <- summary(elast.lm)$coefficients[2, 2]
df <- nrow(HPRICE2) - 2
(t.value <- (slope-1)/se) # Note E(slope)=1 under H0
(2*pt(-abs(t.value),df = df)
## Test for H0: beta_log(crime)=1
slope <- coef(elast.lm)[2]
se <- summary(elast.lm)$coefficients[2, 2]
df <- nrow(HPRICE2) - 2
(t.value <- (slope-1)/se) # Note E(slope)=1 under H0
(2*pt(-abs(t.value),df = df))
## Test for H0: beta_log(crime)=1
slope <- coef(elast.lm)[2]
se <- summary(elast.lm)$coefficients[2, 2]
df <- nrow(HPRICE2) - 2
(t.value <- (slope-1)/se) # Note E(slope)=1 under H0
2*pt(-abs(t.value),df = df)
View(HPRICE2)
bcReverseMedian <- function(y, lambda){
##
## Predicted Median of Reverse Box-Cox Transformation
##
if (abs(lambda) < 1.0E-6)                                         #1.0E-6 matches bcPower=0
rev.med <- exp(y) else
rev.med <- (lambda*y+1)^(1/lambda)
return(rev.med)
} # end:revBoxCoxMed
bcReverseExpectation <- function(y, lambda, sigma){
##
## Predicted Expectation of Reverse Box-Cox Transformation
##
if (abs(lambda) < 1.0E-6)                                         #1.0E-6 matches bcPower=0
rev.exp <- exp(y+0.5*sigma) else
rev.exp <- (lambda*y+1)^(1/lambda)*(1+0.5*sigma*(1-lambda)/(lambda*y+1)^2)
return(rev.exp)
} # end:bcRevExp
plotBoxCox <- function(y, x, ylambda, xlambda){
###################################################################
## calibrates the model lm(bcPower(y,ylambda)~bcPower(x,xlambda))##
## Performs a prediction in the transformed system               ##
## Maps predicted values back into the untransformed system      ##
###################################################################
require(car)
## Transform both variables
y.bc <- bcPower(y,ylambda)
x.bc <- bcPower(x,xlambda)
## Calibrate transformed model and perform prediciton
lm.mod <- lm(y.bc~x.bc)
sigma <- sum(lm.mod$residuals^2)/(length(lm.mod$residuals)-2)        # estimate residual variance
x.line <- data.frame(x.bc=seq(min(x.bc),max(x.bc),length.out=1000))  # get smooth line
pred.line <- predict(lm.mod,x.line)                                  # predict y along line
y.med.line <- bcReverseMedian(pred.line,ylambda)                     # predicted median
y.exp.line <- bcReverseExpectation(pred.line,ylambda,sigma)          # predicted expectation
x.med.line <- bcReverseMedian(x.line$x.bc,xlambda)                   # rescaled independent variable
## Plot data in the original measurement system
plot(x,y,pch=20,
xlab=deparse(substitute(x)), ylab=deparse(substitute(y)),
main="Predictions after Reverse Box-Cox Transformation")
## Plot prediciton lines
lines(x.med.line,y.med.line,col="green",lwd=2)                       # conditional median
lines(x.med.line,y.exp.line,col="red",lwd=2)                         # conditional expectation
legend("topright",title="Conditional Predictions",inset=0.01,bg="white",
legend=c("Median Method","Expectation Method"),col=c("green","red"),lwd=2)
pred.pts <- predict(lm.mod)
pred <- data.frame(y= y, y.pred.med= bcReverseMedian(pred.pts,ylambda),
y.pred.exp= bcReverseExpectation(pred.pts,ylambda,sigma),x=x)
invisible(pred)
} #end:plotBoxCox
plotBoxCox(HPRICE2$price,HPRICE2$dist,0,0)
bcReverseMedian <- function(y, lambda){
##
## Predicted Median of Reverse Box-Cox Transformation
##
if (abs(lambda) < 1.0E-6)                                         #1.0E-6 matches bcPower=0
rev.med <- exp(y) else
rev.med <- (lambda*y+1)^(1/lambda)
return(rev.med)
} # end:revBoxCoxMed
bcReverseExpectation <- function(y, lambda, sigma){
##
## Predicted Expectation of Reverse Box-Cox Transformation
##
if (abs(lambda) < 1.0E-6)                                         #1.0E-6 matches bcPower=0
rev.exp <- exp(y+0.5*sigma) else
rev.exp <- (lambda*y+1)^(1/lambda)*(1+0.5*sigma*(1-lambda)/(lambda*y+1)^2)
return(rev.exp)
} # end:bcRevExp
plotBoxCox <- function(y, x, ylambda, xlambda){
###################################################################
## calibrates the model lm(bcPower(y,ylambda)~bcPower(x,xlambda))##
## Performs a prediction in the transformed system               ##
## Maps predicted values back into the untransformed system      ##
###################################################################
require(car)
## Transform both variables
y.bc <- bcPower(y,ylambda)
x.bc <- bcPower(x,xlambda)
## Calibrate transformed model and perform prediciton
lm.mod <- lm(y.bc~x.bc)
sigma <- sum(lm.mod$residuals^2)/(length(lm.mod$residuals)-2)        # estimate residual variance
x.line <- data.frame(x.bc=seq(min(x.bc),max(x.bc),length.out=1000))  # get smooth line
pred.line <- predict(lm.mod,x.line)                                  # predict y along line
y.med.line <- bcReverseMedian(pred.line,ylambda)                     # predicted median
y.exp.line <- bcReverseExpectation(pred.line,ylambda,sigma)          # predicted expectation
x.med.line <- bcReverseMedian(x.line$x.bc,xlambda)                   # rescaled independent variable
## Plot data in the original measurement system
plot(x,y,pch=20,
xlab=deparse(substitute(x)), ylab=deparse(substitute(y)),
main="Predictions after Reverse Box-Cox Transformation")
## Plot prediciton lines
lines(x.med.line,y.med.line,col="green",lwd=2)                       # conditional median
lines(x.med.line,y.exp.line,col="red",lwd=2)                         # conditional expectation
legend("topright",title="Conditional Predictions",inset=0.01,bg="white",
legend=c("Median Method","Expectation Method"),col=c("green","red"),lwd=2)
pred.pts <- predict(lm.mod)
pred <- data.frame(y= y, y.pred.med= bcReverseMedian(pred.pts,ylambda),
y.pred.exp= bcReverseExpectation(pred.pts,ylambda,sigma),x=x)
invisible(pred)
} #end:plotBoxCox
plotBoxCox(HPRICE2$price,HPRICE2$dist,0,0)
library(RColorBrewer)
display.brewer.all()
library(TexMix)
library(rgdal)
#Get polygons of neighboring countries
neig.shp <- readOGR(dsn="./Italy",layer = "Neighbors", integer64 ="allow.loss")
#Get polygons of Italy provinces
Italy.shp <- readOGR(dsn="./Italy",layer = "Provinces", integer64 = "allow.loss")
Italy.bbox <- bbox(Italy.shp)
plot(neig.shp,axes = T,col=grey(0.9),border = "white", xlim=Italy.bbox[1,], ylim=Italy.bbox[2,])
mapColorQual(as.factor(Italy.shp$REGION), Italy.shp,
map.title="Region Map of Italy",
legend.title = "Regions",add.to.map=T)
plot(neig.shp,axes=T,col=grey(0.9),border="white",
xlim=Italy.bbox[1,], ylim=Italy.bbox[2,])
# addToMap=T over-plots provinces over neighbors
mapColorRamp(Italy.shp$TOTFERTRAT,Italy.shp, breaks=7,
map.title="Italy Fertility Rate ",
legend.title="Fertility Rate",add.to.map=T,
legend.cex=0.7)
Italy.shp$logMigRatio <- log(Italy.shp$INFLOW/Italy.shp$OUTFLOW)
hist(Italy.shp$logMigRatio)
plot(neig.shp,axes=T,col=grey(0.9),border="white",
xlim=Italy.bbox[1,], ylim=Italy.bbox[2,])
sum(Italy.shp$logMigRatio <= 0)
sum(Italy.shp$logMigRatio >= 0)
mapBiPolar(Italy.shp$logMigRatio, Italy.shp,
neg.breaks=3, pos.breaks=5, break.value=0,
map.title="Italy Migration Ratio",
legend.title="Ratio",add.to.map=T,
legend.cex=0.7)
plot(neig.shp, axes=T, col=grey(0.9), border="white",xlim=Italy.bbox[1,], ylim=Italy.bbox[2,])
mapBiPolar(Italy.shp$logMigRatio, Italy.shp, neg.breaks=4, pos.breaks=4,  break.value=median(Italy.shp$logMigRatio),map.title="Below and Above Median Population Change",legend.title="Migration\nChange",legend.cex=0.8, add.to.map=T)
library(gcookbook) # Load gcookbook for the climate data set
library(dplyr)
library(ggplot2)
climate_sub <- climate %>%
filter(Source == "Berkeley" & Year >= 1900) %>%
mutate(pos = Anomaly10y >= 0)
ggplot(climate_sub, aes(x = Year, y = Anomaly10y, fill = pos)) +
geom_col(position = "identity", colour = "black", size = 0.25) +
scale_fill_manual(values = c("#CCEEFF", "#FFDDDD"), guide = FALSE)
library(MASS)
biopsy_mod <- biopsy %>% mutate(classn = recode(class, benign=0, malignant=1))
ggplot(biopsy_mod, aes(x=V1, y=classn))+
geom_point(position=position_jitter(width=0.3, height=0.06), alpha=0.4, shape=21, size=1.5)+
stat_smooth(method=glm, method.args=list(family=binomial))
ggplot(heightweight, aes(x=sex, y=heightIn)) +
geom_boxplot(outlier.colour = NA, width= 0.4)+
geom_dotplot(binaxis = "y", binwidth = 0.5, stackdir = "center", fill=NA)
ggplot(faithful, aes(x=eruptions, y=waiting))+
geom_point()+
stat_density2d(aes(alpha=..density..), geom="tile", contour = FALSE)
concord <- foreign::read.spss('Concord1.sav',to.data.frame = TRUE)
# par(mfrow(1,2))
hist(concord$income, breaks=seq(0,100,by=2.5), freq=FALSE,
ylim=c(0,0.05), xlab="Income in $1000",
main="Income Distribution in the City of Concord")
rug(jitter(concord$income, factor=1), side=1)
lines(density(concord$income, bw=1), lwd=2)
hist(concord$income, breaks=seq(0,100,by=20), freq=FALSE,
ylim=c(0,0.05), xlab="Income in $1000",
main="Income Distribution in the City of Concord")
rug(jitter(concord$income, factor=1), side=1)
lines(density(concord$income, bw=10), lwd=2)
stem(concord$income)
?stem
table(concord$income)
summary(concord$income)
plot(neig.shp,axes=T,col=grey(0.9),border="white",
xlim=Italy.bbox[1,], ylim=Italy.bbox[2,])
sum(Italy.shp$logMigRatio <= 0)
sum(Italy.shp$logMigRatio >= 0)
mapBiPolar(Italy.shp$logMigRatio, Italy.shp,
neg.breaks=3, pos.breaks=5, break.value=0,
map.title="Italy Migration Ratio",
legend.title="Ratio",add.to.map=T,
legend.cex=0.7)
plot(neig.shp,axes=T,col=grey(0.9),border="white",
xlim=Italy.bbox[1,], ylim=Italy.bbox[2,])
sum(Italy.shp$logMigRatio <= 0)
sum(Italy.shp$logMigRatio >= 0)
mapBiPolar(Italy.shp$logMigRatio, Italy.shp,
neg.breaks=3, pos.breaks=5, break.value=0,
map.title="Italy Migration Ratio",
legend.title="Ratio",add.to.map=T,
legend.cex=0.7)
plot(neig.shp,axes=T,col=grey(0.9),border="white",
xlim=Italy.bbox[1,], ylim=Italy.bbox[2,])
sum(Italy.shp$logMigRatio <= 0)
sum(Italy.shp$logMigRatio >= 0)
mapBiPolar(Italy.shp$logMigRatio, Italy.shp,
neg.breaks=3, pos.breaks=5, break.value=0,
map.title="Italy Migration Ratio",
legend.title="Ratio",add.to.map=T,
legend.cex=0.7)
plot(neig.shp,axes=T,col=grey(0.9),border="white",
xlim=Italy.bbox[1,], ylim=Italy.bbox[2,])
sum(Italy.shp$logMigRatio <= 0)
sum(Italy.shp$logMigRatio >= 0)
mapBiPolar(Italy.shp$logMigRatio, Italy.shp,
neg.breaks=3, pos.breaks=5, break.value=0,
map.title="Italy Migration Ratio",
legend.title="Ratio",add.to.map=T,
legend.cex=0.7)
plot(neig.shp,axes=T,col=grey(0.9),border="white",
xlim=Italy.bbox[1,], ylim=Italy.bbox[2,])
sum(Italy.shp$logMigRatio <= 0)
sum(Italy.shp$logMigRatio >= 0)
mapBiPolar(Italy.shp$logMigRatio, Italy.shp,
neg.breaks=3, pos.breaks=5, break.value=0,
map.title="Italy Migration Ratio",
legend.title="Ratio",add.to.map=T,
legend.cex=0.7)
plot(neig.shp,axes=T,col=grey(0.9),border="white",
xlim=Italy.bbox[1,], ylim=Italy.bbox[2,])
sum(Italy.shp$logMigRatio <= 0)
sum(Italy.shp$logMigRatio >= 0)
mapBiPolar(Italy.shp$logMigRatio, Italy.shp,
neg.breaks=3, pos.breaks=5, break.value=0,
map.title="Italy Migration Ratio",
legend.title="Ratio",add.to.map=T,
legend.cex=0.7)
above_mean <- concord$water81 > meanWater
above_mean <- concord$water81 > meanWater
meanWater <- rowMeans(concord[c("water79","water80","water81")],na.rm=T)
above_mean <- concord$water81 > meanWater
concord$case[above_mean]
above_mean <- concord$water81 > meanWater
concord$case[above_mean]
?sample
??sample
?sample
library(foreign)
concord <- read.spss('Concord1.sav',to.data.frame = TRUE)
is.na(concord)
concord[is.na(concord)]
concord$case[!is.na(concord)]
concord$case[!is.na(concord)]
bcpower
?bcpower
??bcPower
regPred <- predict(reg, interval="prediction", level = 0.90)
library(foreign)
Concord <- read.spss('Concord1.sav', to.data.frame=TRUE)
summary(lm(income~educat, data=Concord))
reg <- lm(income~educat, data=Concord)
cbind("Coef"=coef(reg), confint(reg, level=0.99))
regPred <- predict(reg, interval="prediction", level = 0.90)
ConcordPred <- data.frame(Concord,regPred)
plot(income~educat,data=ConcordPred, main = "Point Prediction and Confidence Interval")
lines(ConcordPred$educat,ConcordPred$fit,col="red")
lines(ConcordPred$educat,ConcordPred$lwr,col="green")
lines(ConcordPred$educat,ConcordPred$upr,col="green")
abline(h=mean(ConcordPred$income), lty=3)
abline(v=mean(ConcordPred$educat), lty=3)
regPred <- predict(reg, interval="prediction", level = 0.90)
regPred <- predict(reg, level = 0.90)
ConcordPred <- data.frame(Concord,regPred)
plot(income~educat,data=ConcordPred, main = "Point Prediction and Confidence Interval")
lines(ConcordPred$educat,ConcordPred$fit,col="red")
lines(ConcordPred$educat,ConcordPred$lwr,col="green")
lines(ConcordPred$educat,ConcordPred$upr,col="green")
abline(h=mean(ConcordPred$income), lty=3)
abline(v=mean(ConcordPred$educat), lty=3)
?predict
regPred <- predict(reg, interval="prediction", level = 0.90)
# regPred <- predict(reg, interval="prediction", level = 0.90)
ConcordPred <- data.frame(Concord,regPred)
plot(income~educat,data=ConcordPred, main = "Point Prediction and Confidence Interval")
lines(ConcordPred$educat,ConcordPred$fit,col="red")
lines(ConcordPred$educat,ConcordPred$lwr,col="green")
lines(ConcordPred$educat,ConcordPred$upr,col="green")
abline(h=mean(ConcordPred$income), lty=3)
abline(v=mean(ConcordPred$educat), lty=3)
?powerTransform
X <- matrix(c(1,1,1,1,1,1,2,4,2,4,2,6), nrow=6)
y<- matrix(c(2,5,2,5,2,9), nrow=6)
solve(crossprod(X), crossprod(X,y))
X <- matrix(c(1,1,1,2,4,6), nrow=3)
y<- matrix(c(2,5,9), nrow=3)
W <- diag(c(3,2,1))
solve(t(X)%*%W%*%X, t(X)%*%W%*%y)
(y <- matrix(c(7, 5, 3, 1, 3, 2, 9, 5, 7), ncol = 1))
(X1 <- matrix(c(rep(1, 12), rep(0, 9), rep(1, 3), rep(0, 3)), ncol = 3))
(X2 <- matrix(c(rep(1, 12), rep(0, 12), rep(1, 3)), ncol = 3))
(X3 <- matrix(c(rep(1, 12), rep(0, 3), rep(-1, 3), rep(0, 3), rep(1, 3),rep(-1, 3)), ncol = 3))
(X4 <- matrix(c(rep(1, 12), rep(-1, 3), rep(0, 6), rep(-1, 3), rep(1, 3)), ncol = 3))
(mean.group1 <- mean(y[1:3]))
(mean.group2 <- mean(y[4:6]))
(mean.group3 <- mean(y[7:9]))
(mean.global <- mean(y))
Best <- function (x,y){solve(t(x)%*%x)%*%t(x)%*%y}
(parameter1 <- Best(X1,y))
(parameter2 <- Best(X2,y))
(parameter3 <- Best(X3,y))
(parameter4 <- Best(X4,y))
Best <- function (x,y){solve(t(x)%*%x)%*%t(x)%*%y}
(parameter1 <- Best(X1,Y))
car::avPlots(model.final)
car::influenceIndexPlot(model.final, id.n=2)
X <- matrix(c(1,1,1,1,1,1,2,4,2,4,2,6), nrow=6)
y<- matrix(c(2,5,2,5,2,9), nrow=6)
solve(crossprod(X), crossprod(X,y))
X <- matrix(c(1,1,1,2,4,6), nrow=3)
y<- matrix(c(2,5,9), nrow=3)
W <- diag(c(3,2,1))
solve(t(X)%*%W%*%X, t(X)%*%W%*%y)
(y <- matrix(c(7, 5, 3, 1, 3, 2, 9, 5, 7), ncol = 1))
(X1 <- matrix(c(rep(1, 12), rep(0, 9), rep(1, 3), rep(0, 3)), ncol = 3))
(X2 <- matrix(c(rep(1, 12), rep(0, 12), rep(1, 3)), ncol = 3))
(X3 <- matrix(c(rep(1, 12), rep(0, 3), rep(-1, 3), rep(0, 3), rep(1, 3),rep(-1, 3)), ncol = 3))
(X4 <- matrix(c(rep(1, 12), rep(-1, 3), rep(0, 6), rep(-1, 3), rep(1, 3)), ncol = 3))
(mean.group1 <- mean(y[1:3]))
(mean.group2 <- mean(y[4:6]))
(mean.group3 <- mean(y[7:9]))
(mean.global <- mean(y))
Best <- function (x,y){solve(t(x)%*%x)%*%t(x)%*%y}
(parameter1 <- Best(X1,y))
(parameter2 <- Best(X2,y))
(parameter3 <- Best(X3,y))
(parameter4 <- Best(X4,y))
Best <- function (x,y){solve(t(x)%*%x)%*%t(x)%*%y}
(parameter1 <- Best(X1,Y))
car::influenceIndexPlot(model.final, id.n=2)
car::influenceIndexPlot(model.final, id.n=2)
car::influenceIndexPlot(model.final, id.n=2)
model.final <-lm(log(wage)~education+experience+I(experience^2)+gender+occupation+union, data=CPS1985)
X <- matrix(c(1,1,1,1,1,1,2,4,2,4,2,6), nrow=6)
y<- matrix(c(2,5,2,5,2,9), nrow=6)
solve(crossprod(X), crossprod(X,y))
X <- matrix(c(1,1,1,2,4,6), nrow=3)
y<- matrix(c(2,5,9), nrow=3)
W <- diag(c(3,2,1))
solve(t(X)%*%W%*%X, t(X)%*%W%*%y)
(y <- matrix(c(7, 5, 3, 1, 3, 2, 9, 5, 7), ncol = 1))
(X1 <- matrix(c(rep(1, 12), rep(0, 9), rep(1, 3), rep(0, 3)), ncol = 3))
(X2 <- matrix(c(rep(1, 12), rep(0, 12), rep(1, 3)), ncol = 3))
(X3 <- matrix(c(rep(1, 12), rep(0, 3), rep(-1, 3), rep(0, 3), rep(1, 3),rep(-1, 3)), ncol = 3))
(X4 <- matrix(c(rep(1, 12), rep(-1, 3), rep(0, 6), rep(-1, 3), rep(1, 3)), ncol = 3))
(mean.group1 <- mean(y[1:3]))
(mean.group2 <- mean(y[4:6]))
(mean.group3 <- mean(y[7:9]))
(mean.global <- mean(y))
Best <- function (x,y){solve(t(x)%*%x)%*%t(x)%*%y}
(parameter1 <- Best(X1,y))
(parameter2 <- Best(X2,y))
(parameter3 <- Best(X3,y))
(parameter4 <- Best(X4,y))
Best <- function (x,y){solve(t(x)%*%x)%*%t(x)%*%y}
(parameter1 <- Best(X1,Y))
X <- matrix(c(1,1,1,1,1,1,2,4,2,4,2,6), nrow=6)
y<- matrix(c(2,5,2,5,2,9), nrow=6)
solve(crossprod(X), crossprod(X,y))
X <- matrix(c(1,1,1,2,4,6), nrow=3)
y<- matrix(c(2,5,9), nrow=3)
W <- diag(c(3,2,1))
solve(t(X)%*%W%*%X, t(X)%*%W%*%y)
(y <- matrix(c(7, 5, 3, 1, 3, 2, 9, 5, 7), ncol = 1))
(X1 <- matrix(c(rep(1, 12), rep(0, 9), rep(1, 3), rep(0, 3)), ncol = 3))
(X2 <- matrix(c(rep(1, 12), rep(0, 12), rep(1, 3)), ncol = 3))
(X3 <- matrix(c(rep(1, 12), rep(0, 3), rep(-1, 3), rep(0, 3), rep(1, 3),rep(-1, 3)), ncol = 3))
(X4 <- matrix(c(rep(1, 12), rep(-1, 3), rep(0, 6), rep(-1, 3), rep(1, 3)), ncol = 3))
(mean.group1 <- mean(y[1:3]))
(mean.group2 <- mean(y[4:6]))
(mean.group3 <- mean(y[7:9]))
(mean.global <- mean(y))
Best <- function (x,y){solve(t(x)%*%x)%*%t(x)%*%y}
(parameter1 <- Best(X1,y))
(parameter2 <- Best(X2,y))
(parameter3 <- Best(X3,y))
(parameter4 <- Best(X4,y))
data("CPS1985",package="AER")
rownames(CPS1985) <- 1:nrow(CPS1985)
library(car)
scatterplotMatrix(~log(wage)+education+age+experience, data=CPS1985, spread = FALSE, id.cex=1.5)
model1 <- lm(log(wage)~education+experience, data=CPS1985)
summary(model1)
vif(model1)
model2 <- lm(log(wage)~education+experience+age, data=CPS1985)
summary(model2)
vif(model2)
model.full <- lm(log(wage)~education+experience+gender+occupation+union, data=CPS1985)
summary(model.full)
model.test <- lm(log(wage)~education+experience+gender+union, data=CPS1985)
anova(model.test, model.full)
car::residualPlots(model.full, main="Full model")
model.final <-lm(log(wage)~education+experience+I(experience^2)+gender+occupation+union, data=CPS1985)
car::qqPlot(model.final, id.n=2)
car::influenceIndexPlot(model.final, id.n=2)
car::avPlots(model.final)
car::avPlots(model.final)
df <- car::influenceIndexPlot(model.final, id.n=2)
d
df
df <- car::avPlots(model.final)
df$unionyes
car::qqPlot(model.final, id.n=2)
id <- car::qqPlot(model.final, id.n=2)
id
id <- car::residualPlots(model.full, main="Full model")
id
CPS1985[c(63,171,200,347), ]
CPS1985[c(63,171,200,347), ]
write.csv(CPS1985[c(63,171,200,347), ],file = 'test.csv')
