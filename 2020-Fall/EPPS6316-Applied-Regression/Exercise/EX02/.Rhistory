library(foreign)
Concord <- read.spss('Concord1.sav', to.data.frame=TRUE)
summary(lm(income~educat, data=Concord))
reg <- lm(income~educat, data=Concord)
cbind("Coef"=coef(reg), confint(reg, level=0.99))
regPred <- predict(reg, interval="prediction", level = 0.90)
ConcordPred <- data.frame(Concord,regPred)
plot(income~educat,data=ConcordPred, main = "Point Prediction and Confidence Interval")
lines(ConcordPred$educat,ConcordPred$fit,col="red")
lines(ConcordPred$educat,ConcordPred$lwr,col="green")
lines(ConcordPred$educat,ConcordPred$upr,col="green")
abline(h=mean(ConcordPred$income), lty=3)
abline(v=mean(ConcordPred$educat), lty=3)
library(AER);library(car);library(e1071)
data(CPS1985)
summary(powerTransform(CPS1985$wage~1))
par(mfrow = c(1,3))
hist(car::bcPower(CPS1985$wage, lambda=1),breaks = 12,main = 'lambda = 1',xlab = 'x')
hist(car::bcPower(CPS1985$wage, lambda= -0.0658 ),breaks = 12,main = 'lambda = -0.0658',xlab = 'x')
hist(car::bcPower(CPS1985$wage, lambda= -1.5 ),breaks = 12,main = 'lambda = -1.5',xlab = 'x')
HPRICE2 <- foreign::read.dta('HPRICE2.DTA')
scatterplot(price ~ dist , data = HPRICE2,pch=1, smooth=list(span = 0.35,lty.smooth=1, col.smooth="red", col.var="red"),regLine=list(col="green"))
## Transformation of independent variable
summary(powerTransform(lm(dist~1, data=HPRICE2)))
## Transformation of dependent variable so residuals become approx. symmetric
summary(powerTransform((lm(price~log(dist), data=HPRICE2))))
## Estimate the elasticity model
elast.lm <- lm(log(price)~log(dist), data=HPRICE2)
summary(elast.lm)
## Test for H0: beta_log(dist)=1
slope <- coef(elast.lm)[2]
se <- summary(elast.lm)$coefficients[2, 2]
df <- nrow(HPRICE2) - 2
(t.value <- (slope-1)/se) # Note E(slope)=1 under H0
2*pt(-abs(t.value),df = df) # one-sided significance using cumulative distribution
bcReverseMedian <- function(y, lambda){
##
## Predicted Median of Reverse Box-Cox Transformation
##
if (abs(lambda) < 1.0E-6)                                         #1.0E-6 matches bcPower=0
rev.med <- exp(y) else
rev.med <- (lambda*y+1)^(1/lambda)
return(rev.med)
} # end:revBoxCoxMed
bcReverseExpectation <- function(y, lambda, sigma){
##
## Predicted Expectation of Reverse Box-Cox Transformation
##
if (abs(lambda) < 1.0E-6)                                         #1.0E-6 matches bcPower=0
rev.exp <- exp(y+0.5*sigma) else
rev.exp <- (lambda*y+1)^(1/lambda)*(1+0.5*sigma*(1-lambda)/(lambda*y+1)^2)
return(rev.exp)
} # end:bcRevExp
plotBoxCox <- function(y, x, ylambda, xlambda){
###################################################################
## calibrates the model lm(bcPower(y,ylambda)~bcPower(x,xlambda))##
## Performs a prediction in the transformed system               ##
## Maps predicted values back into the untransformed system      ##
###################################################################
require(car)
## Transform both variables
y.bc <- bcPower(y,ylambda)
x.bc <- bcPower(x,xlambda)
## Calibrate transformed model and perform prediciton
lm.mod <- lm(y.bc~x.bc)
sigma <- sum(lm.mod$residuals^2)/(length(lm.mod$residuals)-2)        # estimate residual variance
x.line <- data.frame(x.bc=seq(min(x.bc),max(x.bc),length.out=1000))  # get smooth line
pred.line <- predict(lm.mod,x.line)                                  # predict y along line
y.med.line <- bcReverseMedian(pred.line,ylambda)                     # predicted median
y.exp.line <- bcReverseExpectation(pred.line,ylambda,sigma)          # predicted expectation
x.med.line <- bcReverseMedian(x.line$x.bc,xlambda)                   # rescaled independent variable
## Plot data in the original measurement system
plot(x,y,pch=20,
xlab=deparse(substitute(x)), ylab=deparse(substitute(y)),
main="Predictions after Reverse Box-Cox Transformation")
## Plot prediciton lines
lines(x.med.line,y.med.line,col="green",lwd=2)                       # conditional median
lines(x.med.line,y.exp.line,col="red",lwd=2)                         # conditional expectation
legend("topright",title="Conditional Predictions",inset=0.01,bg="white",
legend=c("Median Method","Expectation Method"),col=c("green","red"),lwd=2)
pred.pts <- predict(lm.mod)
pred <- data.frame(y= y, y.pred.med= bcReverseMedian(pred.pts,ylambda),
y.pred.exp= bcReverseExpectation(pred.pts,ylambda,sigma),x=x)
invisible(pred)
} #end:plotBoxCox
plotBoxCox(HPRICE2$price,HPRICE2$dist,0,0)
boxplot(tract$PCTUNIVDEG~tract$CITYPERI, main="% of population 25+ with a univeristy degrees",xlab = "Location",ylab="Precentage")
BiModalityIndex <- function(x, show=TRUE){
########################################################
## Bimodality index. BM > 0.55 means multimodality    ##
## Input:  numeric data vector                        ##
## Output: mean, sd, skewness, kurtosis, bm-index     ##
########################################################
if (!is.numeric(x)) stop("Input vector not numeric")
n1 <- length(x)
x <- x[!is.na(x)]
n <- length(x)
if (n < n1) warning("There are some missing input values")
if (n < 4) stop("At least 4 observations are needed for calculation")
x.mean <- mean(x)
x.sd <- sd(x)
x.skew <- e1071::skewness(x) # library e1071 required for kurtosis and skewness
x.kurt <- e1071::kurtosis(x)
x.bm <- (x.skew^2+1)/(x.kurt+(3*(n-1)^2)/((n-2)*(n-3)))
if(show){
BmResults <- c("Mean"=round(x.mean,3),"Std"=round(x.sd,3),
"Skew"=round(x.skew,3),"Kurt"=round(x.kurt,3),
"BMIndex"=round(x.bm,3))
print(BmResults)
}
invisible( list(mean=x.mean,sd=x.sd,skew=x.skew,kurt=x.kurt,bimod=x.bm) )
} # end::BiModalityIndex
makeMixDist <- function(nCount, mixProp=1, mu1, sd1, mu2=mu1, sd2=sd1,shuffle=TRUE ){
#######################################################################
## Generates a mixture of two random normal distributed variables
##
##  Inputs: nCount   Total number of observations
##          mixProp  Proportion of observation in the first group
##          mu1      Mean of the first group
##          sd1      Standard deviation of the first group
##          mu2      Mean of the second group
##          sd2      Standard deviation of the second group
##          shuffle  Mixed sequence of observation in both groups
#######################################################################
if((mixProp < 0) | (mixProp > 1)) stop("Mixture proportion must be in the interval 0<=mixProp<=1")
if(sd1 <= 0) stop("First standard deviation must be larger than 0")
if(sd2 <= 0) stop("Second standard deviation must be larger than 0")
x1 <- rnorm(nCount*mixProp, mu1, sd1)         # first normal parent distribution
x2 <- rnorm(nCount*(1-mixProp), mu2, sd2)     # second normal parent distribution
xLabel <- factor(c(rep("G1",length(x1)),rep("G2",length(x2))))
x <- data.frame(rNorm=c(x1,x2),xGroup=xLabel)
if(shuffle==TRUE){
randSort <- runif(length(x1)+length(x2))
x <- x[order(randSort), ]       # randomly mix both vectors
}
return(x)
} # end::makeMixDist
mixHist <- function(x, myClass=NULL, myTitle="Name"){
##
## Generates boxplots and histograms of a mixture of two groups
## Input:  x        data-frame with random variables rNorm
##                  and group factor xGroup
##         myClass  bin definition for histogram
##         myTitle  title of the plots
##
gMean <- tapply(x$rNorm, x$xGroup, mean)      # group means
gSd <-tapply(x$rNorm, x$xGroup, sd)           # group sd
gCount <- tapply(x$rNorm, x$xGroup, length)   # cases by group
gStats <- data.frame(Groups=levels(x$xGroup), gMean=gMean, gSd=gSd,gCount=gCount)
## Generate proportion based normal density curves for both G1 and G2
xRange <- range(x$rNorm)
xSeq <- seq(xRange[1],xRange[2],length=1000)
g1Density <- dnorm(xSeq,mean=gMean[1],sd=gSd[1])*gCount[1]/sum(gCount)
g2Density <- dnorm(xSeq,mean=gMean[2],sd=gSd[2])*gCount[2]/sum(gCount)
xDen <- hist(x$rNorm, nclass=myClass, plot=FALSE)$density
yMax <- max(g1Density,g2Density,xDen)
## Plot group normal density and rescale by proportion in full dataset
title <- paste("Histogram:\nMixture Distribution of",myTitle)
hist(x$rNorm,probability=TRUE,ylim=c(0,yMax),col="grey",xlab="Mixed X", main=title)       #base histogram
lines(xSeq,g1Density,col="red",lwd=2)
lines(xSeq,g2Density,col="blue",lwd=2)
rug(x[x$xGroup=="G1",1], col="red")
rug(x[x$xGroup=="G2",1], col="blue")
abline(h=0,lwd=2)
## Plot boxplots
title <- paste("Joint Box-Plot:\nMixture Distribution of",myTitle)
boxplot(x$rNorm, xlab="Mixed X", main=title, horizontal=T)      # joint box plot
rug(x[x$xGroup=="G1",1], side=1,col="red")
rug(x[x$xGroup=="G2",1], side=1, col="blue")
title <- paste("Group-wise Box-Plot:\nMixture Distribution of",myTitle)
boxplot(x$rNorm~x$xGroup, xlab="Mixed X", main=title, horizontal=T, varwidth=TRUE)
rug(x[x$xGroup=="G1",1], side=1,col="red")
rug(x[x$xGroup=="G2",1], side=1, col="blue")
invisible(gStats)    # return statistics only if assigned to variable
} #end::mixHist
## Generate Mixture distribution of two normal parent distributions
x <- makeMixDist(1000, mixProp=0.5, mu1=-1, sd1=1, mu2=1, sd2=1)
BiModVal <- BiModalityIndex(x[,1],show=F)[[5]]
mixHist(x, myTitle="Test Model")     # visulize mixture distribution
cat("\n\nDescriptive Statistics of Joint Mixture Distribution:\n")
print(round( c("Mean:"= mean(x[,1]), "WinMean@10%"= mean(x[,1],trim=0.1),
"SD:"= sd(x[,1]), "Skew:"= e1071::skewness(x[,1]), "Kurt:"= e1071::kurtosis(x[,1]),
"BiModIdx:"= BiModVal ), 3))
library(TexMix)
data("tractShp")
tract <- as.data.frame(tractShp)
summary(tract$PCTUNIVDEG)
?tractShp
hist(na.omit(tract$PCTUNIVDEG),breaks = 12,main="% of population 25+ with a univeristy degrees")
boxplot(na.omit(tract$PCTUNIVDEG),breaks = 12,main="% of population 25+ with a univeristy degrees")
boxplot(tract$PCTUNIVDEG~tract$CITYPERI, main="% of population 25+ with a univeristy degrees",xlab = "Location",ylab="Precentage")
tapply(tract$PCTUNIVDEG, tract$CITYPERI, summary)
skewness(tract$PCTUNIVDEG)
skewness(tract$PCTUNIVDEG)
skewness(tract$PCTUNIVDEG,na.rm = TRUE)
skewness(tract$PCTUNIVDEG,na.rm = TRUE)
summary(tract$PCTUNIVDEG)
DF <- aggregate (PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x),sd =sd(x), Number = length(x))})
DF <- aggregate (PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x),sd =sd(x), Number = length(x))})
DF
DF <- aggregate (PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x),sd =sd(x), Number = length(x))})
DF
DF <- aggregate (PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x),sd =sd(x), Number = length(x))})
DF
View(DF)
DF
DF <- aggregate(PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x),sd =sd(x), Number = length(x))})
DF
View(DF)
DF <- aggregate(PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x,na.rm = TRUE),sd =sd(x,na.rm = TRUE), Number = length(x))})
DF
View(DF)
?aggregate
??aggregate
?aggregate
DF <- aggregate(PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x,na.rm = TRUE),sd =sd(x,na.rm = TRUE), Number = length(x))})
DF
DF <- stats::aggregate(PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x,na.rm = TRUE),sd =sd(x,na.rm = TRUE), Number = length(x))})
DF
DF <- stats::aggregate(PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x,na.rm = TRUE),sd =sd(x,na.rm = TRUE), Number = length(x))})
DF
View(DF)
BiModalityIndex <- function(x, show=TRUE){
########################################################
## Bimodality index. BM > 0.55 means multimodality    ##
## Input:  numeric data vector                        ##
## Output: mean, sd, skewness, kurtosis, bm-index     ##
########################################################
if (!is.numeric(x)) stop("Input vector not numeric")
n1 <- length(x)
x <- x[!is.na(x)]
n <- length(x)
if (n < n1) warning("There are some missing input values")
if (n < 4) stop("At least 4 observations are needed for calculation")
x.mean <- mean(x)
x.sd <- sd(x)
x.skew <- e1071::skewness(x) # library e1071 required for kurtosis and skewness
x.kurt <- e1071::kurtosis(x)
x.bm <- (x.skew^2+1)/(x.kurt+(3*(n-1)^2)/((n-2)*(n-3)))
if(show){
BmResults <- c("Mean"=round(x.mean,3),"Std"=round(x.sd,3),
"Skew"=round(x.skew,3),"Kurt"=round(x.kurt,3),
"BMIndex"=round(x.bm,3))
print(BmResults)
}
invisible( list(mean=x.mean,sd=x.sd,skew=x.skew,kurt=x.kurt,bimod=x.bm) )
} # end::BiModalityIndex
makeMixDist <- function(nCount, mixProp=1, mu1, sd1, mu2=mu1, sd2=sd1,shuffle=TRUE ){
#######################################################################
## Generates a mixture of two random normal distributed variables
##
##  Inputs: nCount   Total number of observations
##          mixProp  Proportion of observation in the first group
##          mu1      Mean of the first group
##          sd1      Standard deviation of the first group
##          mu2      Mean of the second group
##          sd2      Standard deviation of the second group
##          shuffle  Mixed sequence of observation in both groups
#######################################################################
if((mixProp < 0) | (mixProp > 1)) stop("Mixture proportion must be in the interval 0<=mixProp<=1")
if(sd1 <= 0) stop("First standard deviation must be larger than 0")
if(sd2 <= 0) stop("Second standard deviation must be larger than 0")
x1 <- rnorm(nCount*mixProp, mu1, sd1)         # first normal parent distribution
x2 <- rnorm(nCount*(1-mixProp), mu2, sd2)     # second normal parent distribution
xLabel <- factor(c(rep("G1",length(x1)),rep("G2",length(x2))))
x <- data.frame(rNorm=c(x1,x2),xGroup=xLabel)
if(shuffle==TRUE){
randSort <- runif(length(x1)+length(x2))
x <- x[order(randSort), ]       # randomly mix both vectors
}
return(x)
} # end::makeMixDist
mixHist <- function(x, myClass=NULL, myTitle="Name"){
##
## Generates boxplots and histograms of a mixture of two groups
## Input:  x        data-frame with random variables rNorm
##                  and group factor xGroup
##         myClass  bin definition for histogram
##         myTitle  title of the plots
##
gMean <- tapply(x$rNorm, x$xGroup, mean)      # group means
gSd <-tapply(x$rNorm, x$xGroup, sd)           # group sd
gCount <- tapply(x$rNorm, x$xGroup, length)   # cases by group
gStats <- data.frame(Groups=levels(x$xGroup), gMean=gMean, gSd=gSd,gCount=gCount)
## Generate proportion based normal density curves for both G1 and G2
xRange <- range(x$rNorm)
xSeq <- seq(xRange[1],xRange[2],length=1000)
g1Density <- dnorm(xSeq,mean=gMean[1],sd=gSd[1])*gCount[1]/sum(gCount)
g2Density <- dnorm(xSeq,mean=gMean[2],sd=gSd[2])*gCount[2]/sum(gCount)
xDen <- hist(x$rNorm, nclass=myClass, plot=FALSE)$density
yMax <- max(g1Density,g2Density,xDen)
## Plot group normal density and rescale by proportion in full dataset
title <- paste("Histogram:\nMixture Distribution of",myTitle)
hist(x$rNorm,probability=TRUE,ylim=c(0,yMax),col="grey",xlab="Mixed X", main=title)       #base histogram
lines(xSeq,g1Density,col="red",lwd=2)
lines(xSeq,g2Density,col="blue",lwd=2)
rug(x[x$xGroup=="G1",1], col="red")
rug(x[x$xGroup=="G2",1], col="blue")
abline(h=0,lwd=2)
## Plot boxplots
title <- paste("Joint Box-Plot:\nMixture Distribution of",myTitle)
boxplot(x$rNorm, xlab="Mixed X", main=title, horizontal=T)      # joint box plot
rug(x[x$xGroup=="G1",1], side=1,col="red")
rug(x[x$xGroup=="G2",1], side=1, col="blue")
title <- paste("Group-wise Box-Plot:\nMixture Distribution of",myTitle)
boxplot(x$rNorm~x$xGroup, xlab="Mixed X", main=title, horizontal=T, varwidth=TRUE)
rug(x[x$xGroup=="G1",1], side=1,col="red")
rug(x[x$xGroup=="G2",1], side=1, col="blue")
invisible(gStats)    # return statistics only if assigned to variable
} #end::mixHist
## Generate Mixture distribution of two normal parent distributions
x <- makeMixDist(1000, mixProp=0.5, mu1=-1, sd1=1, mu2=1, sd2=1)
BiModVal <- BiModalityIndex(x[,1],show=F)[[5]]
mixHist(x, myTitle="Test Model")     # visulize mixture distribution
cat("\n\nDescriptive Statistics of Joint Mixture Distribution:\n")
print(round( c("Mean:"= mean(x[,1]), "WinMean@10%"= mean(x[,1],trim=0.1),
"SD:"= sd(x[,1]), "Skew:"= e1071::skewness(x[,1]), "Kurt:"= e1071::kurtosis(x[,1]),
"BiModIdx:"= BiModVal ), 3))
library(TexMix)
data("tractShp")
tract <- as.data.frame(tractShp)
summary(tract$PCTUNIVDEG)
?tractShp
hist(na.omit(tract$PCTUNIVDEG),breaks = 12,main="% of population 25+ with a univeristy degrees")
boxplot(na.omit(tract$PCTUNIVDEG),breaks = 12,main="% of population 25+ with a univeristy degrees")
boxplot(tract$PCTUNIVDEG~tract$CITYPERI, main="% of population 25+ with a univeristy degrees",xlab = "Location",ylab="Precentage")
tapply(tract$PCTUNIVDEG, tract$CITYPERI, summary)
skewness(tract$PCTUNIVDEG,na.rm = TRUE)
summary(tract$PCTUNIVDEG)
aggr
DF <- stats::aggregate(PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x,na.rm = TRUE),sd =sd(x,na.rm = TRUE), Number = length(x))})
DF
DF <- stats::aggregate(PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x,na.rm = TRUE),sd =sd(x,na.rm = TRUE), Number = length(x))})
DF
View(DF)
tract$CITYPERI
View(DF)
DF <- stats::aggregate(PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x,na.rm = TRUE),sd =sd(x,na.rm = TRUE), Number = length(x))})
DF
RegularMean <- mean(tract$MEDVALHOME)
(RegularMean <- mean(tract$MEDVALHOME))
(RegularMean <- mean(tract$PCTUNIVDEG,na.rm = TRUE))
DF
DF <- stats::aggregate(PCTUNIVDEG~CITYPERI,data = tract,function(x){ c(mean = mean(x,na.rm = TRUE),sd =sd(x,na.rm = TRUE), Number = length(x))})
DF <- as.data.frame(DF)
View(DF)
(RegularMean <- mean(tract$PCTUNIVDEG,na.rm = TRUE))
WeightMean <- weighted.mean(DF$MEDVALHOME[,1], DF$MEDVALHOME[,3])
DF$PCTUNIVDEG
(RegularMean <- mean(tract$PCTUNIVDEG,na.rm = TRUE))
(WeightMean <- weighted.mean(DF$PCTUNIVDEG[,1], DF$PCTUNIVDEG[,3]))
m <- merge(DF, tract, by="CITYPERI")
head(m)
head(m)
head(m)
m <- merge(DF$PCTUNIVDEG, tract, by="CITYPERI")
m <- merge(data.frame(DF$PCTUNIVDE,DF$CITYPERI), tract, by="CITYPERI")
data.frame(DF$PCTUNIVDE,DF$CITYPERI)
DF <- data.frame(DF$PCTUNIVDE,DF$CITYPERI)
# DF <- data.frame(DF$PCTUNIVDE,DF$CITYPERI)
m <- merge(DF, tract, by="CITYPERI")
?merge
# DF <- data.frame(DF$PCTUNIVDE,DF$CITYPERI)
m <- merge(DF, tract, by.x = "DF.CITYPERI",by.y="CITYPERI")
head(m)
head(m)
library(foreign)
Concord <- read.spss('Concord1.sav', to.data.frame=TRUE)
summary(lm(income~educat, data=Concord))
reg <- lm(income~educat, data=Concord)
cbind("Coef"=coef(reg), confint(reg, level=0.99))
regPred <- predict(reg, interval="prediction", level = 0.90)
ConcordPred <- data.frame(Concord,regPred)
plot(income~educat,data=ConcordPred, main = "Point Prediction and Confidence Interval")
lines(ConcordPred$educat,ConcordPred$fit,col="red")
lines(ConcordPred$educat,ConcordPred$lwr,col="green")
lines(ConcordPred$educat,ConcordPred$upr,col="green")
abline(h=mean(ConcordPred$income), lty=3)
abline(v=mean(ConcordPred$educat), lty=3)
library(AER);library(car);library(e1071)
data(CPS1985)
summary(powerTransform(CPS1985$wage~1))
par(mfrow = c(1,3))
hist(car::bcPower(CPS1985$wage, lambda=1),breaks = 12,main = 'lambda = 1',xlab = 'x')
hist(car::bcPower(CPS1985$wage, lambda= -0.0658 ),breaks = 12,main = 'lambda = -0.0658',xlab = 'x')
hist(car::bcPower(CPS1985$wage, lambda= -1 ),breaks = 12,main = 'lambda = -1.5',xlab = 'x')
par(mfrow = c(1,3))
hist(car::bcPower(CPS1985$wage, lambda=1),breaks = 12,main = 'lambda = 1',xlab = 'x')
hist(car::bcPower(CPS1985$wage, lambda= -0.0658 ),breaks = 12,main = 'lambda = -0.0658',xlab = 'x')
hist(car::bcPower(CPS1985$wage, lambda= -1 ),breaks = 12,main = 'lambda = -1',xlab = 'x')
skewness(car::bcPower(CPS1985$wage, lambda=1))
skewness(car::bcPower(CPS1985$wage, lambda=-0.0658))
skewness(car::bcPower(CPS1985$wage, lambda=-1))
skewness(car::bcPower(CPS1985$wage))
skewness(CPS1985$wage)
skewness(car::bcPower(CPS1985$wage, lambda=1))
skewness(car::bcPower(CPS1985$wage, lambda=-0.0658))
skewness(car::bcPower(CPS1985$wage, lambda=-1))
shapiro.test(car::bcPower(CPS1985$wage, lambda=-1))
HPRICE2 <- foreign::read.dta('HPRICE2.DTA')
scatterplot(price ~ dist , data = HPRICE2,pch=1, smooth=list(span = 0.35,lty.smooth=1, col.smooth="red", col.var="red"),regLine=list(col="green"))
## Transformation of independent variable
summary(powerTransform(lm(dist~1, data=HPRICE2)))
## Transformation of dependent variable so residuals become approx. symmetric
summary(powerTransform((lm(price~log(dist), data=HPRICE2))))
